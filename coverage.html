
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>koemoji-go: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/hirokitakamura/koemoji-go/cmd/koemoji-go/main.go (0.0%)</option>
				
				<option value="file1">github.com/hirokitakamura/koemoji-go/internal/config/config.go (3.9%)</option>
				
				<option value="file2">github.com/hirokitakamura/koemoji-go/internal/gui/app.go (0.0%)</option>
				
				<option value="file3">github.com/hirokitakamura/koemoji-go/internal/gui/components.go (0.0%)</option>
				
				<option value="file4">github.com/hirokitakamura/koemoji-go/internal/gui/dialogs.go (0.0%)</option>
				
				<option value="file5">github.com/hirokitakamura/koemoji-go/internal/gui/icons/icon.go (0.0%)</option>
				
				<option value="file6">github.com/hirokitakamura/koemoji-go/internal/gui/window.go (0.0%)</option>
				
				<option value="file7">github.com/hirokitakamura/koemoji-go/internal/llm/llm.go (17.6%)</option>
				
				<option value="file8">github.com/hirokitakamura/koemoji-go/internal/logger/logger.go (0.0%)</option>
				
				<option value="file9">github.com/hirokitakamura/koemoji-go/internal/processor/processor.go (2.3%)</option>
				
				<option value="file10">github.com/hirokitakamura/koemoji-go/internal/recorder/recorder.go (45.1%)</option>
				
				<option value="file11">github.com/hirokitakamura/koemoji-go/internal/recorder/wav.go (0.0%)</option>
				
				<option value="file12">github.com/hirokitakamura/koemoji-go/internal/ui/messages.go (0.0%)</option>
				
				<option value="file13">github.com/hirokitakamura/koemoji-go/internal/ui/ui.go (0.0%)</option>
				
				<option value="file14">github.com/hirokitakamura/koemoji-go/internal/whisper/whisper.go (7.7%)</option>
				
				<option value="file15">github.com/hirokitakamura/koemoji-go/test/recorder_manual.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "context"
        "flag"
        "fmt"
        "io"
        "log"
        "os"
        "os/signal"
        "path/filepath"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/hirokitakamura/koemoji-go/internal/config"
        "github.com/hirokitakamura/koemoji-go/internal/gui"
        "github.com/hirokitakamura/koemoji-go/internal/logger"
        "github.com/hirokitakamura/koemoji-go/internal/processor"
        "github.com/hirokitakamura/koemoji-go/internal/recorder"
        "github.com/hirokitakamura/koemoji-go/internal/ui"
        "github.com/hirokitakamura/koemoji-go/internal/whisper"
)

const version = "1.3.0"

// Color constants
const (
        ColorReset  = "\033[0m"
        ColorRed    = "\033[31m" // ERROR
        ColorGreen  = "\033[32m" // DONE
        ColorYellow = "\033[33m" // PROC
        ColorBlue   = "\033[34m" // INFO
        ColorGray   = "\033[37m" // DEBUG
)

type App struct {
        *config.Config
        configPath     string
        logger         *log.Logger
        debugMode      bool
        wg             sync.WaitGroup
        processedFiles map[string]bool
        mu             sync.Mutex

        // UI related fields
        startTime    time.Time
        lastScanTime time.Time
        logBuffer    []logger.LogEntry
        logMutex     sync.RWMutex
        inputCount   int
        outputCount  int
        archiveCount int

        // Queue management for sequential processing
        queuedFiles    []string // 処理待ちファイルキュー
        processingFile string   // 現在処理中のファイル名（表示用）
        isProcessing   bool     // 処理中フラグ

        // Recording related fields
        recorder           *recorder.Recorder
        isRecording        bool
        recordingStartTime time.Time
}

func main() <span class="cov0" title="0">{
        configPath, debugMode, showVersion, showHelp, configMode, guiMode := parseFlags()

        if showVersion </span><span class="cov0" title="0">{
                fmt.Printf("KoeMoji-Go v%s\n", version)
                return
        }</span>

        <span class="cov0" title="0">if showHelp </span><span class="cov0" title="0">{
                showHelpText()
                return
        }</span>

        // Handle GUI mode
        <span class="cov0" title="0">if guiMode </span><span class="cov0" title="0">{
                gui.Run(configPath, debugMode)
                return
        }</span>

        <span class="cov0" title="0">app := &amp;App{
                configPath:     configPath,
                debugMode:      debugMode,
                processedFiles: make(map[string]bool),
                startTime:      time.Now(),
                logBuffer:      make([]logger.LogEntry, 0, 12),
                queuedFiles:    make([]string, 0),
        }

        app.initLogger()
        cfg := config.LoadConfig(configPath, app.logger)
        app.Config = cfg

        if configMode </span><span class="cov0" title="0">{
                config.ConfigureSettings(app.Config, configPath, app.logger)
                return
        }</span>

        <span class="cov0" title="0">processor.EnsureDirectories(app.Config, app.logger)
        whisper.EnsureDependencies(app.Config, app.logger, &amp;app.logBuffer, &amp;app.logMutex, app.debugMode)
        app.run()</span>
}

func parseFlags() (string, bool, bool, bool, bool, bool) <span class="cov0" title="0">{
        configPath := flag.String("config", "config.json", "Path to config file")
        debugMode := flag.Bool("debug", false, "Enable debug mode")
        showVersion := flag.Bool("version", false, "Show version")
        showHelp := flag.Bool("help", false, "Show help")
        configMode := flag.Bool("configure", false, "Enter configuration mode")
        guiMode := flag.Bool("gui", false, "Run in GUI mode")
        flag.Parse()
        return *configPath, *debugMode, *showVersion, *showHelp, *configMode, *guiMode
}</span>

func showHelpText() <span class="cov0" title="0">{
        fmt.Println("KoeMoji-Go - Audio/Video Transcription Tool")
        fmt.Printf("Version: %s\n\n", version)
        fmt.Println("Usage: koemoji-go [options]")
        fmt.Println("\nOptions:")
        flag.PrintDefaults()
        fmt.Println("\nModes:")
        fmt.Println("  Default - Terminal UI (TUI) mode")
        fmt.Println("  --gui   - Graphical User Interface (GUI) mode")
        fmt.Println("\nInteractive commands (TUI mode only):")
        fmt.Println("  c - Configure settings")
        fmt.Println("  l - Display all logs")
        fmt.Println("  s - Scan now")
        fmt.Println("  i - Open input directory")
        fmt.Println("  o - Open output directory")
        fmt.Println("  a - Toggle AI summary")
        fmt.Println("  q - Quit")
        fmt.Println("  Enter - Refresh display")
}</span>

func (app *App) initLogger() <span class="cov0" title="0">{
        logFile, err := os.OpenFile("koemoji.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to open log file: %v", err)
        }</span>

        // Only timestamps for file logging, no prefix for console
        <span class="cov0" title="0">app.logger = log.New(io.MultiWriter(logFile), "", log.LstdFlags)
        logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "KoeMoji-Go v%s started", version)</span>
}

func (app *App) run() <span class="cov0" title="0">{
        // Phase 2: Create context for graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
        defer signal.Stop(sigChan)

        go processor.StartProcessing(ctx, app.Config, app.logger, &amp;app.logBuffer, &amp;app.logMutex,
                &amp;app.lastScanTime, &amp;app.queuedFiles, &amp;app.processingFile, &amp;app.isProcessing,
                &amp;app.processedFiles, &amp;app.mu, &amp;app.wg, app.debugMode)
        go app.handleUserInput(ctx)

        logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "KoeMoji-Go is running. Use commands below to interact.")
        logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "Monitoring %s directory every %d minutes", app.Config.InputDir, app.Config.ScanIntervalMinutes)

        // Display initial dashboard
        // Brief wait for initialization
        time.Sleep(100 * time.Millisecond)
        ui.RefreshDisplay(app.Config, app.startTime, app.lastScanTime, &amp;app.logBuffer,
                &amp;app.logMutex, app.inputCount, app.outputCount, app.archiveCount,
                &amp;app.queuedFiles, app.processingFile, app.isProcessing, &amp;app.mu,
                app.isRecording, app.recordingStartTime)

        &lt;-sigChan
        logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "Graceful shutdown initiated...")
        cancel() // Signal all goroutines to stop
        
        // Wait for graceful shutdown with timeout
        done := make(chan bool, 1)
        go func() </span><span class="cov0" title="0">{
                app.wg.Wait()
                done &lt;- true
        }</span>()
        
        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "Shutdown completed successfully")</span>
        case &lt;-time.After(10 * time.Second):<span class="cov0" title="0">
                logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "Shutdown timeout, forcing exit")</span>
        }
}

func (app *App) handleUserInput(ctx context.Context) <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "User input handler stopped")
                        return</span>
                default:<span class="cov0" title="0"></span>
                        // Non-blocking input check would be complex, so we keep the blocking read
                        // The context cancellation will be handled when the process exits
                }
                <span class="cov0" title="0">input, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(input)) </span>{
                case "":<span class="cov0" title="0">
                        // Empty Enter = manual refresh
                        ui.RefreshDisplay(app.Config, app.startTime, app.lastScanTime, &amp;app.logBuffer,
                                &amp;app.logMutex, app.inputCount, app.outputCount, app.archiveCount,
                                &amp;app.queuedFiles, app.processingFile, app.isProcessing, &amp;app.mu,
                                app.isRecording, app.recordingStartTime)</span>
                case "c":<span class="cov0" title="0">
                        config.ConfigureSettings(app.Config, app.configPath, app.logger)
                        ui.RefreshDisplay(app.Config, app.startTime, app.lastScanTime, &amp;app.logBuffer,
                                &amp;app.logMutex, app.inputCount, app.outputCount, app.archiveCount,
                                &amp;app.queuedFiles, app.processingFile, app.isProcessing, &amp;app.mu,
                                app.isRecording, app.recordingStartTime)</span>
                case "l":<span class="cov0" title="0">
                        ui.DisplayLogs(app.Config)
                        fmt.Print("Press Enter to continue...")
                        bufio.NewReader(os.Stdin).ReadString('\n')
                        ui.RefreshDisplay(app.Config, app.startTime, app.lastScanTime, &amp;app.logBuffer,
                                &amp;app.logMutex, app.inputCount, app.outputCount, app.archiveCount,
                                &amp;app.queuedFiles, app.processingFile, app.isProcessing, &amp;app.mu,
                                app.isRecording, app.recordingStartTime)</span>
                case "s":<span class="cov0" title="0">
                        logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "Manual scan triggered")
                        go processor.ScanAndProcess(app.Config, app.logger, &amp;app.logBuffer, &amp;app.logMutex,
                                &amp;app.lastScanTime, &amp;app.queuedFiles, &amp;app.processingFile, &amp;app.isProcessing,
                                &amp;app.processedFiles, &amp;app.mu, &amp;app.wg, app.debugMode)</span>
                case "i":<span class="cov0" title="0">
                        if err := ui.OpenDirectory(app.Config.InputDir); err != nil </span><span class="cov0" title="0">{
                                logger.LogError(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "Failed to open input directory: %v", err)
                        }</span>
                case "o":<span class="cov0" title="0">
                        if err := ui.OpenDirectory(app.Config.OutputDir); err != nil </span><span class="cov0" title="0">{
                                logger.LogError(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "Failed to open output directory: %v", err)
                        }</span>
                case "r":<span class="cov0" title="0">
                        app.handleRecordingToggle()</span>
                case "q":<span class="cov0" title="0">
                        logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "Shutting down KoeMoji-Go...")
                        os.Exit(0)</span>
                default:<span class="cov0" title="0">
                        if strings.TrimSpace(input) != "" </span><span class="cov0" title="0">{
                                fmt.Printf("Invalid command '%s' (use c/l/s/i/o/a/r/q or Enter to refresh)\n", strings.TrimSpace(input))
                        }</span>
                }
        }
}

func (app *App) handleRecordingToggle() <span class="cov0" title="0">{
        if app.isRecording </span><span class="cov0" title="0">{
                // Stop recording
                app.stopRecording()
        }</span> else<span class="cov0" title="0"> {
                // Start recording
                app.startRecording()
        }</span>
}

func (app *App) startRecording() <span class="cov0" title="0">{
        // Initialize recorder if not already done
        if app.recorder == nil </span><span class="cov0" title="0">{
                var err error
                if app.Config.RecordingDeviceID == -1 </span><span class="cov0" title="0">{
                        app.recorder, err = recorder.NewRecorder()
                }</span> else<span class="cov0" title="0"> {
                        app.recorder, err = recorder.NewRecorderWithDevice(app.Config.RecordingDeviceID)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "録音の初期化に失敗: %v", err)
                        return
                }</span>
                
                // Phase 1: Set recording limits
                <span class="cov0" title="0">var maxDuration time.Duration
                var maxFileSize int64
                
                if app.Config.RecordingMaxHours &gt; 0 </span><span class="cov0" title="0">{
                        maxDuration = time.Duration(app.Config.RecordingMaxHours) * time.Hour
                }</span>
                
                <span class="cov0" title="0">if app.Config.RecordingMaxFileMB &gt; 0 </span><span class="cov0" title="0">{
                        maxFileSize = int64(app.Config.RecordingMaxFileMB) * 1024 * 1024 // Convert MB to bytes
                }</span>
                
                <span class="cov0" title="0">app.recorder.SetLimits(maxDuration, maxFileSize)</span>
        }

        // Start recording
        <span class="cov0" title="0">err := app.recorder.Start()
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "録音の開始に失敗: %v", err)
                return
        }</span>

        <span class="cov0" title="0">app.isRecording = true
        app.recordingStartTime = time.Now()
        logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "録音を開始しました")

        // Refresh display to show recording status
        ui.RefreshDisplay(app.Config, app.startTime, app.lastScanTime, &amp;app.logBuffer,
                &amp;app.logMutex, app.inputCount, app.outputCount, app.archiveCount,
                &amp;app.queuedFiles, app.processingFile, app.isProcessing, &amp;app.mu,
                app.isRecording, app.recordingStartTime)</span>
}

func (app *App) stopRecording() <span class="cov0" title="0">{
        if app.recorder == nil </span><span class="cov0" title="0">{
                logger.LogError(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "録音が初期化されていません")
                return
        }</span>

        // Stop recording
        <span class="cov0" title="0">err := app.recorder.Stop()
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "録音の停止に失敗: %v", err)
                return
        }</span>

        // Generate filename with current timestamp
        <span class="cov0" title="0">now := time.Now()
        filename := fmt.Sprintf("recording_%s.wav", now.Format("20060102_1504"))

        // Save to input directory
        outputPath := filepath.Join(app.Config.InputDir, filename)
        err = app.recorder.SaveToFile(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "録音ファイルの保存に失敗: %v", err)
                return
        }</span>

        <span class="cov0" title="0">app.isRecording = false
        duration := time.Since(app.recordingStartTime)
        logger.LogInfo(app.logger, &amp;app.logBuffer, &amp;app.logMutex, "録音を停止しました: %s (時間: %s)", filename, duration.Round(time.Second))

        // Refresh display to remove recording status
        ui.RefreshDisplay(app.Config, app.startTime, app.lastScanTime, &amp;app.logBuffer,
                &amp;app.logMutex, app.inputCount, app.outputCount, app.archiveCount,
                &amp;app.queuedFiles, app.processingFile, app.isProcessing, &amp;app.mu,
                app.isRecording, app.recordingStartTime)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "bufio"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "os/exec"
        "runtime"
        "strconv"
        "strings"

        "github.com/gordonklaus/portaudio"
)

type Config struct {
        WhisperModel        string `json:"whisper_model"`
        Language            string `json:"language"`
        UILanguage          string `json:"ui_language"`
        ScanIntervalMinutes int    `json:"scan_interval_minutes"`
        MaxCpuPercent       int    `json:"max_cpu_percent"`
        ComputeType         string `json:"compute_type"`
        UseColors           bool   `json:"use_colors"`
        OutputFormat        string `json:"output_format"`
        InputDir            string `json:"input_dir"`
        OutputDir           string `json:"output_dir"`
        ArchiveDir          string `json:"archive_dir"`
        // LLM Summary settings
        LLMSummaryEnabled     bool   `json:"llm_summary_enabled"`
        LLMAPIProvider        string `json:"llm_api_provider"`
        LLMAPIKey             string `json:"llm_api_key"`
        LLMModel              string `json:"llm_model"`
        LLMMaxTokens          int    `json:"llm_max_tokens"`
        SummaryPromptTemplate string `json:"summary_prompt_template"`
        SummaryLanguage       string `json:"summary_language"`
        // Recording settings
        RecordingDeviceID     int `json:"recording_device_id"`
        RecordingDeviceName   string `json:"recording_device_name"`
        // Phase 1: Memory-efficient recording limits
        RecordingMaxHours     int `json:"recording_max_hours"`      // 0 = unlimited
        RecordingMaxFileMB    int `json:"recording_max_file_mb"`    // 0 = unlimited
}

func GetDefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                WhisperModel:        "large-v3",
                Language:            "ja",
                UILanguage:          "ja",
                ScanIntervalMinutes: 1,
                MaxCpuPercent:       95,
                ComputeType:         "int8",
                UseColors:           true,
                OutputFormat:        "txt",
                InputDir:            "./input",
                OutputDir:           "./output",
                ArchiveDir:          "./archive",
                // LLM Summary defaults
                LLMSummaryEnabled:     false,
                LLMAPIProvider:        "openai",
                LLMAPIKey:             "",
                LLMModel:              "gpt-4o",
                LLMMaxTokens:          4096,
                SummaryPromptTemplate: "以下の文字起こしテキストを{language}で要約してください。重要なポイントを箇条書きでまとめ、全体の概要も含めてください。\n\n{text}",
                SummaryLanguage:       "auto",
                // Recording defaults
                RecordingDeviceID:     -1, // -1 means use default device
                RecordingDeviceName:   "既定のマイク",
                RecordingMaxHours:     0,  // Unlimited by default
                RecordingMaxFileMB:    0,  // Unlimited by default
        }
}</span>

func LoadConfig(configPath string, logger *log.Logger) *Config <span class="cov8" title="1">{
        // Default config
        config := GetDefaultConfig()

        file, err := os.Open(configPath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        logger.Printf("[INFO] Config file not found, using defaults")
                        return config
                }</span>
                <span class="cov0" title="0">logger.Printf("[ERROR] Failed to load config: %v", err)
                os.Exit(1)</span>
        }
        <span class="cov8" title="1">defer file.Close()

        if err := json.NewDecoder(file).Decode(config); err != nil </span><span class="cov0" title="0">{
                logger.Printf("[ERROR] Failed to parse config: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov8" title="1">return config</span>
}

func SaveConfig(config *Config, configPath string) error <span class="cov8" title="1">{
        file, err := os.Create(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := json.NewEncoder(file)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ConfigureSettings(config *Config, configPath string, logger *log.Logger) <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        modified := false
        msg := getMessages(config)

        for </span><span class="cov0" title="0">{
                fmt.Printf("\n=== %s ===\n", msg.ConfigTitle)
                fmt.Printf("1. %s: %s\n", msg.WhisperModel, config.WhisperModel)
                fmt.Printf("2. %s: %s\n", msg.Language, config.Language)
                fmt.Printf("3. %s: %s\n", msg.UILanguage, config.UILanguage)
                fmt.Printf("4. %s: %d %s\n", msg.ScanInterval, config.ScanIntervalMinutes, msg.Minutes)
                fmt.Printf("5. %s: %d%%\n", msg.MaxCPUPercent, config.MaxCpuPercent)
                fmt.Printf("6. %s: %s\n", msg.ComputeType, config.ComputeType)
                fmt.Printf("7. %s: %t\n", msg.UseColors, config.UseColors)
                fmt.Printf("8. %s: %s\n", msg.OutputFormat, config.OutputFormat)
                fmt.Printf("9. %s: %s\n", msg.InputDirectory, config.InputDir)
                fmt.Printf("10. %s: %s\n", msg.OutputDirectory, config.OutputDir)
                fmt.Printf("11. %s: %s\n", msg.ArchiveDirectory, config.ArchiveDir)
                fmt.Printf("12. %s: %t\n", msg.LLMSummaryEnabled, config.LLMSummaryEnabled)
                fmt.Printf("13. %s: %s\n", msg.LLMAPIProvider, config.LLMAPIProvider)
                fmt.Printf("14. %s: %s\n", msg.LLMAPIKey, getAPIKeyDisplay(config.LLMAPIKey))
                fmt.Printf("15. %s: %s\n", msg.LLMModel, config.LLMModel)
                fmt.Printf("16. %s: %d\n", msg.LLMMaxTokens, config.LLMMaxTokens)
                fmt.Printf("17. %s: [%s]\n", msg.SummaryPrompt, msg.EditablePrompt)
                fmt.Printf("18. %s: %s\n", msg.RecordingDeviceName, config.RecordingDeviceName)
                fmt.Printf("r. %s\n", msg.ResetDefaults)
                fmt.Printf("s. %s\n", msg.SaveAndExit)
                fmt.Printf("q. %s\n", msg.QuitWithoutSave)
                fmt.Printf("\n%s (1-18, r, s, q): ", msg.SelectOption)

                input, _ := reader.ReadString('\n')
                choice := strings.TrimSpace(input)

                switch choice </span>{
                case "1":<span class="cov0" title="0">
                        if configureWhisperModel(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "2":<span class="cov0" title="0">
                        if configureLanguage(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "3":<span class="cov0" title="0">
                        if configureUILanguage(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "4":<span class="cov0" title="0">
                        if configureScanInterval(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "5":<span class="cov0" title="0">
                        if configureMaxCpuPercent(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "6":<span class="cov0" title="0">
                        if configureComputeType(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "7":<span class="cov0" title="0">
                        if configureUseColors(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "8":<span class="cov0" title="0">
                        if configureOutputFormat(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "9":<span class="cov0" title="0">
                        if configureInputDir(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "10":<span class="cov0" title="0">
                        if configureOutputDir(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "11":<span class="cov0" title="0">
                        if configureArchiveDir(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "12":<span class="cov0" title="0">
                        if configureLLMSummaryEnabled(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "13":<span class="cov0" title="0">
                        if configureLLMAPIProvider(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "14":<span class="cov0" title="0">
                        if configureLLMAPIKey(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "15":<span class="cov0" title="0">
                        if configureLLMModel(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "16":<span class="cov0" title="0">
                        if configureLLMMaxTokens(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "17":<span class="cov0" title="0">
                        if configureSummaryPrompt(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "18":<span class="cov0" title="0">
                        if configureRecordingDevice(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "r":<span class="cov0" title="0">
                        if resetToDefaults(config, reader) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                case "s":<span class="cov0" title="0">
                        if modified </span><span class="cov0" title="0">{
                                if err := SaveConfig(config, configPath); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf(msg.ConfigSaveError+"\n", err)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Println(msg.ConfigSaved)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Println(msg.NoChanges)
                        }</span>
                        <span class="cov0" title="0">return</span>
                case "q":<span class="cov0" title="0">
                        if modified </span><span class="cov0" title="0">{
                                fmt.Printf("%s ", msg.UnsavedChanges)
                                confirm, _ := reader.ReadString('\n')
                                if strings.ToLower(strings.TrimSpace(confirm)) != "y" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">return</span>
                default:<span class="cov0" title="0">
                        fmt.Println(msg.InvalidOption)</span>
                }
        }
}

func configureWhisperModel(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        models := []string{
                "tiny", "tiny.en",
                "base", "base.en",
                "small", "small.en",
                "medium", "medium.en",
                "large", "large-v1", "large-v2", "large-v3",
        }
        msg := getMessages(config)

        fmt.Println("\nAvailable Whisper models:")
        for i, model := range models </span><span class="cov0" title="0">{
                fmt.Printf("%d. %s", i+1, model)
                if model == config.WhisperModel </span><span class="cov0" title="0">{
                        fmt.Printf(" (%s)", msg.Current)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }
        <span class="cov0" title="0">fmt.Printf(msg.SelectModel+" ", len(models))

        input, _ := reader.ReadString('\n')
        choice := strings.TrimSpace(input)

        if choice == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if idx, err := strconv.Atoi(choice); err == nil &amp;&amp; idx &gt;= 1 &amp;&amp; idx &lt;= len(models) </span><span class="cov0" title="0">{
                config.WhisperModel = models[idx-1]
                msg2 := getMessages(config)
                fmt.Printf(msg2.ModelSet+"\n", config.WhisperModel)
                return true
        }</span>

        <span class="cov0" title="0">msg2 := getMessages(config)
        fmt.Println(msg2.InvalidOption)
        return false</span>
}

func configureLanguage(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s %s: %s\n", msg.Current, msg.Language, config.Language)
        fmt.Printf("%s ", msg.EnterLanguage)

        input, _ := reader.ReadString('\n')
        newLang := strings.TrimSpace(input)

        if newLang == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">config.Language = newLang
        fmt.Printf(msg.LanguageSet+"\n", config.Language)
        return true</span>
}

func configureScanInterval(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s %s: %d %s\n", msg.Current, msg.ScanInterval, config.ScanIntervalMinutes, msg.Minutes)
        fmt.Printf("%s ", msg.EnterInterval)

        input, _ := reader.ReadString('\n')
        newInterval := strings.TrimSpace(input)

        if newInterval == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if interval, err := strconv.Atoi(newInterval); err == nil &amp;&amp; interval &gt; 0 </span><span class="cov0" title="0">{
                config.ScanIntervalMinutes = interval
                fmt.Printf(msg.IntervalSet+"\n", config.ScanIntervalMinutes)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidInput)
        return false</span>
}

func configureMaxCpuPercent(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s %s: %d%%\n", msg.Current, msg.MaxCPUPercent, config.MaxCpuPercent)
        fmt.Printf("%s ", msg.EnterCPU)

        input, _ := reader.ReadString('\n')
        newPercent := strings.TrimSpace(input)

        if newPercent == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if percent, err := strconv.Atoi(newPercent); err == nil &amp;&amp; percent &gt;= 1 &amp;&amp; percent &lt;= 100 </span><span class="cov0" title="0">{
                config.MaxCpuPercent = percent
                fmt.Printf(msg.CPUSet+"\n", config.MaxCpuPercent)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidInput)
        return false</span>
}

func configureComputeType(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        types := []string{"int8", "int8_float16", "int16", "float16", "float32"}
        msg := getMessages(config)

        fmt.Println("\nAvailable compute types:")
        for i, ctype := range types </span><span class="cov0" title="0">{
                fmt.Printf("%d. %s", i+1, ctype)
                if ctype == config.ComputeType </span><span class="cov0" title="0">{
                        fmt.Printf(" (%s)", msg.Current)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }
        <span class="cov0" title="0">fmt.Printf(msg.SelectCompute+" ", len(types))

        input, _ := reader.ReadString('\n')
        choice := strings.TrimSpace(input)

        if choice == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if idx, err := strconv.Atoi(choice); err == nil &amp;&amp; idx &gt;= 1 &amp;&amp; idx &lt;= len(types) </span><span class="cov0" title="0">{
                config.ComputeType = types[idx-1]
                fmt.Printf(msg.ComputeSet+"\n", config.ComputeType)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidOption)
        return false</span>
}

func configureUILanguage(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        languages := []string{"en", "ja"}
        languageNames := []string{"English", "日本語"}
        msg := getMessages(config)

        fmt.Println("\nAvailable UI languages:")
        for i, lang := range languages </span><span class="cov0" title="0">{
                fmt.Printf("%d. %s (%s)", i+1, lang, languageNames[i])
                if lang == config.UILanguage </span><span class="cov0" title="0">{
                        fmt.Printf(" (%s)", msg.Current)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }
        <span class="cov0" title="0">fmt.Printf("%s ", msg.SelectUILang)

        input, _ := reader.ReadString('\n')
        choice := strings.TrimSpace(input)

        if choice == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if idx, err := strconv.Atoi(choice); err == nil &amp;&amp; idx &gt;= 1 &amp;&amp; idx &lt;= len(languages) </span><span class="cov0" title="0">{
                config.UILanguage = languages[idx-1]
                fmt.Printf(msg.UILanguageSet+"\n", config.UILanguage)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidOption)
        return false</span>
}

func configureUseColors(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s %s: %t\n", msg.Current, msg.UseColors, config.UseColors)
        fmt.Printf("%s ", msg.EnableColors)

        input, _ := reader.ReadString('\n')
        choice := strings.ToLower(strings.TrimSpace(input))

        if choice == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if choice == "y" || choice == "yes" </span><span class="cov0" title="0">{
                config.UseColors = true
                fmt.Println(msg.ColorsEnabled)
                return true
        }</span> else<span class="cov0" title="0"> if choice == "n" || choice == "no" </span><span class="cov0" title="0">{
                config.UseColors = false
                fmt.Println(msg.ColorsDisabled)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidInput)
        return false</span>
}

func configureOutputFormat(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        formats := []string{"txt", "vtt", "srt", "tsv", "json"}
        msg := getMessages(config)

        fmt.Println("\nAvailable output formats:")
        for i, format := range formats </span><span class="cov0" title="0">{
                fmt.Printf("%d. %s", i+1, format)
                if format == config.OutputFormat </span><span class="cov0" title="0">{
                        fmt.Printf(" (%s)", msg.Current)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }
        <span class="cov0" title="0">fmt.Printf(msg.SelectFormat+" ", len(formats))

        input, _ := reader.ReadString('\n')
        choice := strings.TrimSpace(input)

        if choice == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if idx, err := strconv.Atoi(choice); err == nil &amp;&amp; idx &gt;= 1 &amp;&amp; idx &lt;= len(formats) </span><span class="cov0" title="0">{
                config.OutputFormat = formats[idx-1]
                fmt.Printf(msg.FormatSet+"\n", config.OutputFormat)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidOption)
        return false</span>
}

func configureInputDir(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s %s: %s\n", msg.Current, msg.InputDirectory, config.InputDir)
        fmt.Printf("%s ", msg.SelectFolder)

        input, _ := reader.ReadString('\n')
        newDir := strings.TrimSpace(input)

        if newDir == "" </span><span class="cov0" title="0">{
                // Use folder selection dialog
                selectedDir, err := selectFolder("Select Input Directory")
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf(msg.FolderSelectFail+"\n", err)
                        return false
                }</span>
                <span class="cov0" title="0">newDir = selectedDir</span>
        }

        <span class="cov0" title="0">config.InputDir = newDir
        fmt.Printf(msg.InputDirSet+"\n", config.InputDir)
        return true</span>
}

func configureOutputDir(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s %s: %s\n", msg.Current, msg.OutputDirectory, config.OutputDir)
        fmt.Printf("%s ", msg.SelectFolder)

        input, _ := reader.ReadString('\n')
        newDir := strings.TrimSpace(input)

        if newDir == "" </span><span class="cov0" title="0">{
                // Use folder selection dialog
                selectedDir, err := selectFolder("Select Output Directory")
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf(msg.FolderSelectFail+"\n", err)
                        return false
                }</span>
                <span class="cov0" title="0">newDir = selectedDir</span>
        }

        <span class="cov0" title="0">config.OutputDir = newDir
        fmt.Printf(msg.OutputDirSet+"\n", config.OutputDir)
        return true</span>
}

func configureArchiveDir(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s %s: %s\n", msg.Current, msg.ArchiveDirectory, config.ArchiveDir)
        fmt.Printf("%s ", msg.SelectFolder)

        input, _ := reader.ReadString('\n')
        newDir := strings.TrimSpace(input)

        if newDir == "" </span><span class="cov0" title="0">{
                // Use folder selection dialog
                selectedDir, err := selectFolder("Select Archive Directory")
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf(msg.FolderSelectFail+"\n", err)
                        return false
                }</span>
                <span class="cov0" title="0">newDir = selectedDir</span>
        }

        <span class="cov0" title="0">config.ArchiveDir = newDir
        fmt.Printf(msg.ArchiveDirSet+"\n", config.ArchiveDir)
        return true</span>
}

func resetToDefaults(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s ", msg.ResetConfirm)

        input, _ := reader.ReadString('\n')
        choice := strings.ToLower(strings.TrimSpace(input))

        if choice == "y" || choice == "yes" </span><span class="cov0" title="0">{
                defaultConfig := GetDefaultConfig()
                *config = *defaultConfig
                fmt.Println(msg.ConfigReset)
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func selectFolder(title string) (string, error) <span class="cov0" title="0">{
        var cmd *exec.Cmd

        switch runtime.GOOS </span>{
        case "windows":<span class="cov0" title="0">
                cmd = exec.Command("powershell", "-Command",
                        "Add-Type -AssemblyName System.Windows.Forms; "+
                                "$folder = New-Object System.Windows.Forms.FolderBrowserDialog; "+
                                "$folder.Description = '"+title+"'; "+
                                "if ($folder.ShowDialog() -eq 'OK') { $folder.SelectedPath }")</span>
        case "darwin":<span class="cov0" title="0">
                cmd = exec.Command("osascript", "-e",
                        "POSIX path of (choose folder with prompt \""+title+"\")")</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("folder selection not supported on this platform")</span>
        }

        <span class="cov0" title="0">output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">selectedPath := strings.TrimSpace(string(output))
        if selectedPath == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no folder selected")
        }</span>

        <span class="cov0" title="0">return selectedPath, nil</span>
}

// Messages contains all UI text strings
type Messages struct {
        // Config menu
        ConfigTitle      string
        WhisperModel     string
        Language         string
        UILanguage       string
        ScanInterval     string
        MaxCPUPercent    string
        ComputeType      string
        UseColors        string
        UIMode           string
        OutputFormat     string
        InputDirectory   string
        OutputDirectory  string
        ArchiveDirectory string
        // LLM Settings
        LLMSummaryEnabled string
        LLMAPIProvider    string
        LLMAPIKey         string
        LLMModel          string
        LLMMaxTokens      string
        SummaryPrompt     string
        EditablePrompt    string
        // Recording Settings
        RecordingEnabled    string
        RecordingDeviceID   string
        RecordingDeviceName string
        RecordingAutoStart  string
        ResetDefaults       string
        SaveAndExit         string
        QuitWithoutSave     string
        SelectOption        string
        Minutes             string
        Current             string

        // Config prompts
        SelectModel    string
        EnterLanguage  string
        SelectUILang   string
        EnterInterval  string
        EnterCPU       string
        SelectCompute  string
        EnableColors   string
        SelectUIMode   string
        SelectFormat   string
        SelectFolder   string
        ResetConfirm   string
        UnsavedChanges string
        // LLM prompts
        EnableLLMSummary   string
        SelectLLMProvider  string
        EnterLLMAPIKey     string
        SelectLLMModel     string
        EnterLLMMaxTokens  string
        CurrentPrompt      string
        PromptInstructions string
        EnterNewPrompt     string

        // Config messages
        ModelSet       string
        LanguageSet    string
        UILanguageSet  string
        IntervalSet    string
        CPUSet         string
        ComputeSet     string
        ColorsEnabled  string
        ColorsDisabled string
        UIModeSet      string
        FormatSet      string
        InputDirSet    string
        OutputDirSet   string
        ArchiveDirSet  string
        // LLM messages
        LLMSummaryEnabledMsg  string
        LLMSummaryDisabledMsg string
        LLMProviderSet        string
        LLMAPIKeySet          string
        LLMModelSet           string
        LLMMaxTokensSet       string
        PromptSet             string
        // Recording messages
        RecordingEnabledMsg        string
        RecordingDisabledMsg       string
        RecordingDeviceSet         string
        RecordingAutoStartEnabled  string
        RecordingAutoStartDisabled string
        ConfigReset                string
        ConfigSaved                string
        NoChanges                  string
        InvalidOption              string
        InvalidInput               string
        FolderSelectFail           string
        ConfigSaveError            string
}

var messagesEN = Messages{
        // Config menu
        ConfigTitle:      "KoeMoji-Go Configuration",
        WhisperModel:     "Whisper Model",
        Language:         "Language",
        UILanguage:       "UI Language",
        ScanInterval:     "Scan Interval",
        MaxCPUPercent:    "Max CPU Percent",
        ComputeType:      "Compute Type",
        UseColors:        "Use Colors",
        UIMode:           "UI Mode",
        OutputFormat:     "Output Format",
        InputDirectory:   "Input Directory",
        OutputDirectory:  "Output Directory",
        ArchiveDirectory: "Archive Directory",
        // LLM Settings
        LLMSummaryEnabled: "LLM Summary",
        LLMAPIProvider:    "LLM API Provider",
        LLMAPIKey:         "LLM API Key",
        LLMModel:          "LLM Model",
        LLMMaxTokens:      "Max Tokens",
        SummaryPrompt:     "Summary Prompt",
        EditablePrompt:    "Editable",
        // Recording Settings
        RecordingEnabled:    "Recording Enabled",
        RecordingDeviceID:   "Recording Device ID",
        RecordingDeviceName: "Recording Device Name",
        RecordingAutoStart:  "Auto-start Recording",
        ResetDefaults:       "Reset to defaults",
        SaveAndExit:         "Save and exit",
        QuitWithoutSave:     "Quit without saving",
        SelectOption:        "Select option",
        Minutes:             "minutes",
        Current:             "current",

        // Config prompts
        SelectModel:    "Select model (1-%d) or press Enter to keep current:",
        EnterLanguage:  "Enter new language code (e.g., ja, en, zh) or press Enter to keep current:",
        SelectUILang:   "Select UI language (1-2) or press Enter to keep current:",
        EnterInterval:  "Enter new scan interval (minutes) or press Enter to keep current:",
        EnterCPU:       "Enter new max CPU percent (1-100) or press Enter to keep current:",
        SelectCompute:  "Select compute type (1-%d) or press Enter to keep current:",
        EnableColors:   "Enable colors? (y/n) or press Enter to keep current:",
        SelectUIMode:   "Select UI mode (1-2) or press Enter to keep current:",
        SelectFormat:   "Select output format (1-%d) or press Enter to keep current:",
        SelectFolder:   "Press Enter to select folder with dialog, or type path manually:",
        ResetConfirm:   "Are you sure you want to reset all settings to defaults? (y/N):",
        UnsavedChanges: "You have unsaved changes. Are you sure you want to quit? (y/N):",
        // LLM prompts
        EnableLLMSummary:   "Enable LLM summary? (y/n) or press Enter to keep current:",
        SelectLLMProvider:  "Select LLM provider (1-1) or press Enter to keep current:",
        EnterLLMAPIKey:     "Enter LLM API key or press Enter to keep current:",
        SelectLLMModel:     "Select LLM model (1-%d) or press Enter to keep current:",
        EnterLLMMaxTokens:  "Enter max tokens (1-16384) or press Enter to keep current:",
        CurrentPrompt:      "Current prompt",
        PromptInstructions: "Use {text} for content and {language} for language. Enter new prompt:",
        EnterNewPrompt:     "Enter new prompt or press Enter to keep current:",

        // Config messages
        ModelSet:       "Whisper model set to: %s",
        LanguageSet:    "Language set to: %s",
        UILanguageSet:  "UI language set to: %s",
        IntervalSet:    "Scan interval set to: %d minutes",
        CPUSet:         "Max CPU percent set to: %d%%",
        ComputeSet:     "Compute type set to: %s",
        ColorsEnabled:  "Colors enabled",
        ColorsDisabled: "Colors disabled",
        UIModeSet:      "UI mode set to: %s",
        FormatSet:      "Output format set to: %s",
        InputDirSet:    "Input directory set to: %s",
        OutputDirSet:   "Output directory set to: %s",
        ArchiveDirSet:  "Archive directory set to: %s",
        // LLM messages
        LLMSummaryEnabledMsg:  "LLM summary enabled",
        LLMSummaryDisabledMsg: "LLM summary disabled",
        LLMProviderSet:        "LLM provider set to: %s",
        LLMAPIKeySet:          "LLM API key set to: %s",
        LLMModelSet:           "LLM model set to: %s",
        LLMMaxTokensSet:       "Max tokens set to: %d",
        PromptSet:             "Summary prompt updated",
        // Recording messages
        RecordingEnabledMsg:        "Recording enabled",
        RecordingDisabledMsg:       "Recording disabled",
        RecordingDeviceSet:         "Recording device set to: %s",
        RecordingAutoStartEnabled:  "Auto-start recording enabled",
        RecordingAutoStartDisabled: "Auto-start recording disabled",
        ConfigReset:                "Configuration reset to defaults.",
        ConfigSaved:                "Configuration saved successfully!",
        NoChanges:                  "No changes to save.",
        InvalidOption:              "Invalid option. Please try again.",
        InvalidInput:               "Invalid input.",
        FolderSelectFail:           "Folder selection failed: %v",
        ConfigSaveError:            "Failed to save config: %v",
}

var messagesJA = Messages{
        // Config menu
        ConfigTitle:      "KoeMoji-Go 設定",
        WhisperModel:     "Whisperモデル",
        Language:         "認識言語",
        UILanguage:       "UI言語",
        ScanInterval:     "スキャン間隔",
        MaxCPUPercent:    "最大CPU使用率",
        ComputeType:      "計算タイプ",
        UseColors:        "色を使用",
        UIMode:           "UIモード",
        OutputFormat:     "出力フォーマット",
        InputDirectory:   "入力ディレクトリ",
        OutputDirectory:  "出力ディレクトリ",
        ArchiveDirectory: "アーカイブディレクトリ",
        // LLM Settings
        LLMSummaryEnabled: "LLM要約機能",
        LLMAPIProvider:    "LLM APIプロバイダー",
        LLMAPIKey:         "LLM APIキー",
        LLMModel:          "LLMモデル",
        LLMMaxTokens:      "最大トークン数",
        SummaryPrompt:     "要約プロンプト",
        EditablePrompt:    "編集可能",
        // Recording Settings
        RecordingEnabled:    "録音機能",
        RecordingDeviceID:   "録音デバイスID",
        RecordingDeviceName: "録音デバイス名",
        RecordingAutoStart:  "録音自動開始",
        ResetDefaults:       "デフォルトに戻す",
        SaveAndExit:         "保存して終了",
        QuitWithoutSave:     "保存せずに終了",
        SelectOption:        "オプションを選択",
        Minutes:             "分",
        Current:             "現在",

        // Config prompts
        SelectModel:    "モデルを選択 (1-%d) またはEnterで現在の設定を維持:",
        EnterLanguage:  "新しい言語コード (例: ja, en, zh) を入力またはEnterで現在の設定を維持:",
        SelectUILang:   "UI言語を選択 (1-2) またはEnterで現在の設定を維持:",
        EnterInterval:  "新しいスキャン間隔（分）を入力またはEnterで現在の設定を維持:",
        EnterCPU:       "新しい最大CPU使用率 (1-100) を入力またはEnterで現在の設定を維持:",
        SelectCompute:  "計算タイプを選択 (1-%d) またはEnterで現在の設定を維持:",
        EnableColors:   "色を有効にしますか？ (y/n) またはEnterで現在の設定を維持:",
        SelectUIMode:   "UIモードを選択 (1-2) またはEnterで現在の設定を維持:",
        SelectFormat:   "出力フォーマットを選択 (1-%d) またはEnterで現在の設定を維持:",
        SelectFolder:   "Enterでフォルダ選択ダイアログを開く、または手動でパスを入力:",
        ResetConfirm:   "本当にすべての設定をデフォルトに戻しますか？ (y/N):",
        UnsavedChanges: "未保存の変更があります。本当に終了しますか？ (y/N):",
        // LLM prompts
        EnableLLMSummary:   "LLM要約を有効にしますか？ (y/n) またはEnterで現在の設定を維持:",
        SelectLLMProvider:  "LLM APIプロバイダーを選択 (1-1) またはEnterで現在の設定を維持:",
        EnterLLMAPIKey:     "LLM APIキーを入力またはEnterで現在の設定を維持:",
        SelectLLMModel:     "LLMモデルを選択 (1-%d) またはEnterで現在の設定を維持:",
        EnterLLMMaxTokens:  "最大トークン数を入力 (1-16384) またはEnterで現在の設定を維持:",
        CurrentPrompt:      "現在のプロンプト",
        PromptInstructions: "{text}でコンテンツ、{language}で言語を指定できます。新しいプロンプトを入力:",
        EnterNewPrompt:     "新しいプロンプトを入力またはEnterで現在の設定を維持:",

        // Config messages
        ModelSet:       "Whisperモデルを設定: %s",
        LanguageSet:    "言語を設定: %s",
        UILanguageSet:  "UI言語を設定: %s",
        IntervalSet:    "スキャン間隔を設定: %d分",
        CPUSet:         "最大CPU使用率を設定: %d%%",
        ComputeSet:     "計算タイプを設定: %s",
        ColorsEnabled:  "色を有効にしました",
        ColorsDisabled: "色を無効にしました",
        UIModeSet:      "UIモードを設定: %s",
        FormatSet:      "出力フォーマットを設定: %s",
        InputDirSet:    "入力ディレクトリを設定: %s",
        OutputDirSet:   "出力ディレクトリを設定: %s",
        ArchiveDirSet:  "アーカイブディレクトリを設定: %s",
        // LLM messages
        LLMSummaryEnabledMsg:  "LLM要約機能を有効にしました",
        LLMSummaryDisabledMsg: "LLM要約機能を無効にしました",
        LLMProviderSet:        "LLM APIプロバイダーを設定: %s",
        LLMAPIKeySet:          "LLM APIキーを設定: %s",
        LLMModelSet:           "LLMモデルを設定: %s",
        LLMMaxTokensSet:       "最大トークン数を設定: %d",
        PromptSet:             "要約プロンプトを更新しました",
        // Recording messages
        RecordingEnabledMsg:        "録音機能を有効にしました",
        RecordingDisabledMsg:       "録音機能を無効にしました",
        RecordingDeviceSet:         "録音デバイスを設定: %s",
        RecordingAutoStartEnabled:  "録音自動開始を有効にしました",
        RecordingAutoStartDisabled: "録音自動開始を無効にしました",
        ConfigReset:                "設定をデフォルトに戻しました。",
        ConfigSaved:                "設定を保存しました！",
        NoChanges:                  "変更はありません。",
        InvalidOption:              "無効なオプションです。もう一度お試しください。",
        InvalidInput:               "無効な入力です。",
        FolderSelectFail:           "フォルダ選択に失敗: %v",
        ConfigSaveError:            "設定の保存に失敗: %v",
}

// getMessages returns the messages for the current UI language
func getMessages(config *Config) *Messages <span class="cov0" title="0">{
        if config != nil &amp;&amp; config.UILanguage == "ja" </span><span class="cov0" title="0">{
                return &amp;messagesJA
        }</span>
        <span class="cov0" title="0">return &amp;messagesEN</span>
}

// getAPIKeyDisplay returns a display-friendly version of the API key
func getAPIKeyDisplay(apiKey string) string <span class="cov0" title="0">{
        if apiKey == "" </span><span class="cov0" title="0">{
                return "[未設定]"
        }</span>
        <span class="cov0" title="0">if len(apiKey) &gt; 10 </span><span class="cov0" title="0">{
                return apiKey[:4] + "..." + apiKey[len(apiKey)-4:]
        }</span>
        <span class="cov0" title="0">return "[設定済み]"</span>
}

// LLM configuration functions
func configureLLMSummaryEnabled(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s %s: %t\n", msg.Current, msg.LLMSummaryEnabled, config.LLMSummaryEnabled)
        fmt.Printf("%s ", msg.EnableLLMSummary)

        input, _ := reader.ReadString('\n')
        choice := strings.ToLower(strings.TrimSpace(input))

        if choice == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if choice == "y" || choice == "yes" </span><span class="cov0" title="0">{
                config.LLMSummaryEnabled = true
                fmt.Println(msg.LLMSummaryEnabledMsg)
                return true
        }</span> else<span class="cov0" title="0"> if choice == "n" || choice == "no" </span><span class="cov0" title="0">{
                config.LLMSummaryEnabled = false
                fmt.Println(msg.LLMSummaryDisabledMsg)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidInput)
        return false</span>
}

func configureLLMAPIProvider(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        providers := []string{"openai"}
        msg := getMessages(config)

        fmt.Println("\nAvailable LLM providers:")
        for i, provider := range providers </span><span class="cov0" title="0">{
                fmt.Printf("%d. %s", i+1, provider)
                if provider == config.LLMAPIProvider </span><span class="cov0" title="0">{
                        fmt.Printf(" (%s)", msg.Current)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }
        <span class="cov0" title="0">fmt.Printf("%s ", msg.SelectLLMProvider)

        input, _ := reader.ReadString('\n')
        choice := strings.TrimSpace(input)

        if choice == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if idx, err := strconv.Atoi(choice); err == nil &amp;&amp; idx &gt;= 1 &amp;&amp; idx &lt;= len(providers) </span><span class="cov0" title="0">{
                config.LLMAPIProvider = providers[idx-1]
                fmt.Printf(msg.LLMProviderSet+"\n", config.LLMAPIProvider)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidOption)
        return false</span>
}

func configureLLMAPIKey(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s %s: %s\n", msg.Current, msg.LLMAPIKey, getAPIKeyDisplay(config.LLMAPIKey))
        fmt.Printf("%s ", msg.EnterLLMAPIKey)

        input, _ := reader.ReadString('\n')
        newKey := strings.TrimSpace(input)

        if newKey == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">config.LLMAPIKey = newKey
        fmt.Printf(msg.LLMAPIKeySet+"\n", getAPIKeyDisplay(config.LLMAPIKey))
        return true</span>
}

func configureLLMModel(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        models := []string{"gpt-4o", "gpt-4-turbo", "gpt-3.5-turbo", "gpt-3.5-turbo-16k"}
        msg := getMessages(config)

        fmt.Println("\nAvailable LLM models:")
        for i, model := range models </span><span class="cov0" title="0">{
                fmt.Printf("%d. %s", i+1, model)
                if model == config.LLMModel </span><span class="cov0" title="0">{
                        fmt.Printf(" (%s)", msg.Current)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }
        <span class="cov0" title="0">fmt.Printf(msg.SelectLLMModel+" ", len(models))

        input, _ := reader.ReadString('\n')
        choice := strings.TrimSpace(input)

        if choice == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if idx, err := strconv.Atoi(choice); err == nil &amp;&amp; idx &gt;= 1 &amp;&amp; idx &lt;= len(models) </span><span class="cov0" title="0">{
                config.LLMModel = models[idx-1]
                fmt.Printf(msg.LLMModelSet+"\n", config.LLMModel)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidOption)
        return false</span>
}

func configureLLMMaxTokens(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s %s: %d\n", msg.Current, msg.LLMMaxTokens, config.LLMMaxTokens)
        fmt.Printf("%s ", msg.EnterLLMMaxTokens)

        input, _ := reader.ReadString('\n')
        newTokens := strings.TrimSpace(input)

        if newTokens == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if tokens, err := strconv.Atoi(newTokens); err == nil &amp;&amp; tokens &gt; 0 &amp;&amp; tokens &lt;= 16384 </span><span class="cov0" title="0">{
                config.LLMMaxTokens = tokens
                fmt.Printf(msg.LLMMaxTokensSet+"\n", config.LLMMaxTokens)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidInput)
        return false</span>
}

func configureSummaryPrompt(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)
        fmt.Printf("%s:\n%s\n", msg.CurrentPrompt, config.SummaryPromptTemplate)
        fmt.Printf("\n%s\n", msg.PromptInstructions)
        fmt.Printf("%s ", msg.EnterNewPrompt)

        input, _ := reader.ReadString('\n')
        newPrompt := strings.TrimSpace(input)

        if newPrompt == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">config.SummaryPromptTemplate = newPrompt
        fmt.Println(msg.PromptSet)
        return true</span>
}

func configureRecordingDevice(config *Config, reader *bufio.Reader) bool <span class="cov0" title="0">{
        msg := getMessages(config)

        // Initialize PortAudio
        err := portaudio.Initialize()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("録音機能が利用できません: %v\n", err)
                return false
        }</span>
        <span class="cov0" title="0">defer portaudio.Terminate()

        // Get available devices
        devices, err := portaudio.Devices()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("デバイス一覧の取得に失敗: %v\n", err)
                return false
        }</span>

        // Filter input devices
        <span class="cov0" title="0">var inputDevices []*portaudio.DeviceInfo
        var deviceIndices []int

        for _, device := range devices </span><span class="cov0" title="0">{
                if device.MaxInputChannels &gt; 0 </span><span class="cov0" title="0">{
                        inputDevices = append(inputDevices, device)
                        deviceIndices = append(deviceIndices, device.Index)
                }</span>
        }

        <span class="cov0" title="0">if len(inputDevices) == 0 </span><span class="cov0" title="0">{
                fmt.Println("録音デバイスが見つかりません")
                return false
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n%s %s: %s (ID: %d)\n", msg.Current, msg.RecordingDeviceName, config.RecordingDeviceName, config.RecordingDeviceID)
        fmt.Println("\n利用可能な録音デバイス:")

        for i, device := range inputDevices </span><span class="cov0" title="0">{
                fmt.Printf("%d. %s", i+1, device.Name)
                if device.Index == config.RecordingDeviceID </span><span class="cov0" title="0">{
                        fmt.Printf(" (%s)", msg.Current)
                }</span>

                // Check for virtual devices
                <span class="cov0" title="0">name := strings.ToLower(device.Name)
                if strings.Contains(name, "blackhole") || strings.Contains(name, "stereo mix") || strings.Contains(name, "virtual") </span><span class="cov0" title="0">{
                        fmt.Printf(" [仮想デバイス]")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nデバイスを選択 (1-%d) または Enter で現在の設定を維持: ", len(inputDevices))

        input, _ := reader.ReadString('\n')
        choice := strings.TrimSpace(input)

        if choice == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if idx, err := strconv.Atoi(choice); err == nil &amp;&amp; idx &gt;= 1 &amp;&amp; idx &lt;= len(inputDevices) </span><span class="cov0" title="0">{
                selectedDevice := inputDevices[idx-1]
                config.RecordingDeviceID = selectedDevice.Index
                config.RecordingDeviceName = selectedDevice.Name
                fmt.Printf("録音デバイスを設定しました: %s (ID: %d)\n", config.RecordingDeviceName, config.RecordingDeviceID)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(msg.InvalidOption)
        return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package gui

import (
        "context"
        "sync"
        "time"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/app"
        "fyne.io/fyne/v2/widget"

        "github.com/hirokitakamura/koemoji-go/internal/config"
        "github.com/hirokitakamura/koemoji-go/internal/logger"
        "github.com/hirokitakamura/koemoji-go/internal/recorder"
)

// GUIApp represents the GUI application
type GUIApp struct {
        // Core application fields (reused from main.go App struct)
        *config.Config
        configPath     string
        debugMode      bool
        processedFiles map[string]bool
        mu             sync.Mutex

        // UI related fields
        startTime    time.Time
        lastScanTime time.Time
        logBuffer    []logger.LogEntry
        logMutex     sync.RWMutex
        inputCount   int
        outputCount  int
        archiveCount int

        // Queue management for sequential processing
        queuedFiles    []string // 処理待ちファイルキュー
        processingFile string   // 現在処理中のファイル名（表示用）
        isProcessing   bool     // 処理中フラグ

        // GUI specific fields
        fyneApp fyne.App
        window  fyne.Window

        // UI components (will be implemented in components.go)
        statusWidget fyne.CanvasObject
        logWidget    fyne.CanvasObject
        buttonWidget fyne.CanvasObject

        // UI component references for updates
        statusLabel  *widget.Label
        filesLabel   *widget.Label
        timingLabel  *widget.Label
        logText      *widget.RichText
        recordButton *widget.Button

        // Recording related fields
        recorder              *recorder.Recorder
        recordingDeviceSelect *widget.Select
        recordingDeviceMap    map[string]int

        // UI safety fields
        uiInitialized bool
        
        // Phase 2: Context cancellation for goroutines
        ctx        context.Context
        cancelFunc context.CancelFunc
}

// Run starts the GUI application
func Run(configPath string, debugMode bool) <span class="cov0" title="0">{
        // Phase 2: Create context for goroutine management
        ctx, cancel := context.WithCancel(context.Background())
        
        guiApp := &amp;GUIApp{
                configPath:     configPath,
                debugMode:      debugMode,
                processedFiles: make(map[string]bool),
                startTime:      time.Now(),
                logBuffer:      make([]logger.LogEntry, 0, 12),
                queuedFiles:    make([]string, 0),
                ctx:            ctx,
                cancelFunc:     cancel,
        }

        // Initialize the application
        guiApp.fyneApp = app.NewWithID("com.hirokitakamura.koemoji-go")

        // Load configuration
        guiApp.loadConfig()

        // Create and show the main window
        guiApp.createWindow()
        guiApp.window.ShowAndRun()
}</span>

// loadConfig loads the application configuration
func (app *GUIApp) loadConfig() <span class="cov0" title="0">{
        // Initialize logger first (similar to main.go)
        app.initLogger()

        // Load configuration
        cfg := config.LoadConfig(app.configPath, nil) // GUI mode doesn't need file logger
        app.Config = cfg
}</span>

// initLogger initializes the logger (simplified for GUI mode)
func (app *GUIApp) initLogger() <span class="cov0" title="0">{
        // For GUI mode, we'll use in-memory logging only
        // The log buffer will be displayed in the GUI
        logger.LogInfo(nil, &amp;app.logBuffer, &amp;app.logMutex, "KoeMoji-Go v1.3.0 started")
}</span>

// ForceCleanup performs immediate resource cleanup for application exit
func (app *GUIApp) ForceCleanup() <span class="cov0" title="0">{
        // Phase 2: Cancel all goroutines
        if app.cancelFunc != nil </span><span class="cov0" title="0">{
                app.cancelFunc()
        }</span>
        
        // Clean up recorder resources (PortAudio)
        <span class="cov0" title="0">if app.recorder != nil </span><span class="cov0" title="0">{
                app.recorder.Close()
                app.recorder = nil
        }</span>

        // Log cleanup action
        <span class="cov0" title="0">logger.LogInfo(nil, &amp;app.logBuffer, &amp;app.logMutex, "Application resources cleaned up")</span>
}

// isUIReady checks if all essential UI components are initialized
func (app *GUIApp) isUIReady() bool <span class="cov0" title="0">{
        return app.uiInitialized &amp;&amp;
                app.statusLabel != nil &amp;&amp;
                app.filesLabel != nil &amp;&amp;
                app.timingLabel != nil &amp;&amp;
                app.logText != nil &amp;&amp;
                app.recordButton != nil
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package gui

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/widget"
        "github.com/hirokitakamura/koemoji-go/internal/logger"
        "github.com/hirokitakamura/koemoji-go/internal/processor"
        "github.com/hirokitakamura/koemoji-go/internal/recorder"
        "github.com/hirokitakamura/koemoji-go/internal/ui"
        "github.com/hirokitakamura/koemoji-go/internal/whisper"
)

// startPeriodicUpdate starts the 5-second periodic UI update
func (app *GUIApp) startPeriodicUpdate() <span class="cov0" title="0">{
        // Initialize dependencies once
        processor.EnsureDirectories(app.Config, nil)
        whisper.EnsureDependencies(app.Config, nil, &amp;app.logBuffer, &amp;app.logMutex, app.debugMode)

        // Phase 2: Start file processing with context
        go processor.StartProcessing(app.ctx, app.Config, nil, &amp;app.logBuffer, &amp;app.logMutex,
                &amp;app.lastScanTime, &amp;app.queuedFiles, &amp;app.processingFile, &amp;app.isProcessing,
                &amp;app.processedFiles, &amp;app.mu, nil, app.debugMode)

        // Start periodic updates in a goroutine with context cancellation
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(5 * time.Second)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-app.ctx.Done():<span class="cov0" title="0">
                                logger.LogInfo(nil, &amp;app.logBuffer, &amp;app.logMutex, "GUI periodic update stopped")
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                // Use fyne.Do to safely update UI from goroutine
                                fyne.Do(func() </span><span class="cov0" title="0">{
                                        app.updateUI()
                                }</span>)
                        }
                }
        }()
}

// KISS Design: Helper methods for state management
// These provide a simple, consistent interface to recording state

// isRecording returns the current recording state from the single source of truth
func (app *GUIApp) isRecording() bool <span class="cov0" title="0">{
        return app.recorder != nil &amp;&amp; app.recorder.IsRecording()
}</span>

// getRecordingDuration returns the current recording duration
func (app *GUIApp) getRecordingDuration() time.Duration <span class="cov0" title="0">{
        if !app.isRecording() </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return app.recorder.GetElapsedTime()</span>
}

// updateUI updates all UI components with current data
func (app *GUIApp) updateUI() <span class="cov0" title="0">{
        // Check if UI is ready for updates
        if !app.isUIReady() </span><span class="cov0" title="0">{
                return
        }</span>

        // KISS Design: Direct query, no synchronization needed
        <span class="cov0" title="0">isCurrentlyRecording := app.isRecording()

        msg := ui.GetMessages(app.Config)

        // Update file counts
        app.updateFileCounts()

        // Update status label
        status := "🟢 " + msg.Active
        if app.isProcessing </span><span class="cov0" title="0">{
                status = "🟡 " + msg.Processing
        }</span>

        <span class="cov0" title="0">app.mu.Lock()
        queueCount := len(app.queuedFiles)
        processingDisplay := msg.None
        if app.processingFile != "" </span><span class="cov0" title="0">{
                processingDisplay = app.processingFile
        }</span>
        <span class="cov0" title="0">app.mu.Unlock()

        statusText := fmt.Sprintf("%s | %s: %d | %s: %s",
                status, msg.Queue, queueCount, msg.Processing, processingDisplay)

        // Update files label
        filesText := fmt.Sprintf("📁 %s: %d → %s: %d → %s: %d",
                msg.Input, app.inputCount, msg.Output, app.outputCount, msg.Archive, app.archiveCount)

        // Update timing label with recording status
        uptime := time.Since(app.startTime)
        lastScanStr := msg.Never
        nextScanStr := msg.Soon
        if !app.lastScanTime.IsZero() </span><span class="cov0" title="0">{
                lastScanStr = app.lastScanTime.Format("15:04:05")
                nextScan := app.lastScanTime.Add(time.Duration(app.Config.ScanIntervalMinutes) * time.Minute)
                nextScanStr = nextScan.Format("15:04:05")
        }</span>

        <span class="cov0" title="0">timingText := fmt.Sprintf("⏰ %s: %s | %s: %s | %s: %s",
                msg.Last, lastScanStr, msg.Next, nextScanStr, msg.Uptime, formatDuration(uptime))

        // Add recording status if recording
        if isCurrentlyRecording </span><span class="cov0" title="0">{
                elapsed := app.getRecordingDuration()
                timingText += fmt.Sprintf(" | 🔴 %s: %s", msg.Recording, formatDuration(elapsed))
        }</span>

        // Update UI elements on main thread
        <span class="cov0" title="0">app.statusLabel.SetText(statusText)
        app.filesLabel.SetText(filesText)
        app.timingLabel.SetText(timingText)

        // Update log display
        app.updateLogDisplay()</span>
}

// updateFileCounts updates the file count fields
func (app *GUIApp) updateFileCounts() <span class="cov0" title="0">{
        // Count files in each directory (similar to ui/ui.go)
        if entries, err := os.ReadDir(app.Config.InputDir); err == nil </span><span class="cov0" title="0">{
                app.inputCount = 0
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if !entry.IsDir() &amp;&amp; ui.IsAudioFile(entry.Name()) </span><span class="cov0" title="0">{
                                app.inputCount++
                        }</span>
                }
        }

        <span class="cov0" title="0">if entries, err := os.ReadDir(app.Config.OutputDir); err == nil </span><span class="cov0" title="0">{
                app.outputCount = len(entries)
        }</span>

        <span class="cov0" title="0">if entries, err := os.ReadDir(app.Config.ArchiveDir); err == nil </span><span class="cov0" title="0">{
                app.archiveCount = len(entries)
        }</span>
}

// updateLogDisplay updates the log viewer with recent entries
func (app *GUIApp) updateLogDisplay() <span class="cov0" title="0">{
        app.logMutex.RLock()
        defer app.logMutex.RUnlock()

        if len(app.logBuffer) == 0 </span><span class="cov0" title="0">{
                app.logText.ParseMarkdown("**Waiting for log entries...**")
                return
        }</span>

        // Build log text from buffer
        <span class="cov0" title="0">var logText string
        for _, entry := range app.logBuffer </span><span class="cov0" title="0">{
                timestamp := entry.Timestamp.Format("15:04:05")
                // Format: [LEVEL] timestamp message
                logText += fmt.Sprintf("**[%s]** %s %s\n\n", entry.Level, timestamp, entry.Message)
        }</span>

        <span class="cov0" title="0">app.logText.ParseMarkdown(logText)</span>
}

// formatDuration formats a duration for display (copied from ui/ui.go)
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        hours := int(d.Hours())
        minutes := int(d.Minutes()) % 60
        seconds := int(d.Seconds()) % 60

        if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh%dm%ds", hours, minutes, seconds)
        }</span> else<span class="cov0" title="0"> if minutes &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm%ds", minutes, seconds)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%ds", seconds)
        }</span>
}

// Button action handlers

// onConfigPressed handles the config button press
func (app *GUIApp) onConfigPressed() <span class="cov0" title="0">{
        // Show the configuration dialog
        app.showConfigDialog()

        // Log the action
        logger.LogInfo(nil, &amp;app.logBuffer, &amp;app.logMutex, "Configuration dialog opened")
}</span>

// onLogsPressed handles the logs button press
func (app *GUIApp) onLogsPressed() <span class="cov0" title="0">{
        // Open log file using existing UI function
        ui.DisplayLogs(app.Config)

        // Log the action
        logger.LogInfo(nil, &amp;app.logBuffer, &amp;app.logMutex, "Log file opened")
}</span>

// onScanPressed handles the scan button press
func (app *GUIApp) onScanPressed() <span class="cov0" title="0">{
        logger.LogInfo(nil, &amp;app.logBuffer, &amp;app.logMutex, "Manual scan triggered")

        // Use existing sync.WaitGroup reference if available, or create minimal scan
        processor.ScanAndProcess(app.Config, nil, &amp;app.logBuffer, &amp;app.logMutex,
                &amp;app.lastScanTime, &amp;app.queuedFiles, &amp;app.processingFile, &amp;app.isProcessing,
                &amp;app.processedFiles, &amp;app.mu, nil, app.debugMode)
}</span>

// onInputDirPressed handles the input directory button press
func (app *GUIApp) onInputDirPressed() <span class="cov0" title="0">{
        if err := ui.OpenDirectory(app.Config.InputDir); err != nil </span><span class="cov0" title="0">{
                logger.LogError(nil, &amp;app.logBuffer, &amp;app.logMutex, "Failed to open input directory: %v", err)
        }</span>
}

// onOutputDirPressed handles the output directory button press
func (app *GUIApp) onOutputDirPressed() <span class="cov0" title="0">{
        if err := ui.OpenDirectory(app.Config.OutputDir); err != nil </span><span class="cov0" title="0">{
                logger.LogError(nil, &amp;app.logBuffer, &amp;app.logMutex, "Failed to open output directory: %v", err)
        }</span>
}

// onRecordPressed handles the record button press
func (app *GUIApp) onRecordPressed() <span class="cov0" title="0">{
        // KISS Design: Simple toggle logic with single source of truth
        if app.isRecording() </span><span class="cov0" title="0">{
                // Stop recording
                app.stopRecording()
        }</span> else<span class="cov0" title="0"> {
                // Start recording
                app.startRecording()
        }</span>
}

// startRecording starts audio recording
func (app *GUIApp) startRecording() <span class="cov0" title="0">{
        // Initialize recorder if not already done
        if app.recorder == nil </span><span class="cov0" title="0">{
                var err error
                if app.Config.RecordingDeviceID == -1 </span><span class="cov0" title="0">{
                        app.recorder, err = recorder.NewRecorder()
                }</span> else<span class="cov0" title="0"> {
                        app.recorder, err = recorder.NewRecorderWithDevice(app.Config.RecordingDeviceID)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(nil, &amp;app.logBuffer, &amp;app.logMutex, "録音の初期化に失敗: %v", err)
                        return
                }</span>
                
                // Phase 1: Set recording limits
                <span class="cov0" title="0">var maxDuration time.Duration
                var maxFileSize int64
                
                if app.Config.RecordingMaxHours &gt; 0 </span><span class="cov0" title="0">{
                        maxDuration = time.Duration(app.Config.RecordingMaxHours) * time.Hour
                }</span>
                
                <span class="cov0" title="0">if app.Config.RecordingMaxFileMB &gt; 0 </span><span class="cov0" title="0">{
                        maxFileSize = int64(app.Config.RecordingMaxFileMB) * 1024 * 1024 // Convert MB to bytes
                }</span>
                
                <span class="cov0" title="0">app.recorder.SetLimits(maxDuration, maxFileSize)</span>
        }

        // Start recording
        <span class="cov0" title="0">err := app.recorder.Start()
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(nil, &amp;app.logBuffer, &amp;app.logMutex, "録音の開始に失敗: %v", err)
                return
        }</span>

        // KISS Design: No state sync needed, query directly
        <span class="cov0" title="0">if app.isRecording() </span><span class="cov0" title="0">{
                logger.LogInfo(nil, &amp;app.logBuffer, &amp;app.logMutex, "録音を開始しました")
        }</span>

        // Update button appearance
        <span class="cov0" title="0">app.updateRecordingUI()</span>
}

// stopRecording stops audio recording
func (app *GUIApp) stopRecording() <span class="cov0" title="0">{
        if app.recorder == nil </span><span class="cov0" title="0">{
                logger.LogError(nil, &amp;app.logBuffer, &amp;app.logMutex, "録音が初期化されていません")
                app.updateRecordingUI()
                return
        }</span>

        // Stop recording
        <span class="cov0" title="0">err := app.recorder.Stop()
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(nil, &amp;app.logBuffer, &amp;app.logMutex, "録音の停止に失敗: %v", err)
                app.updateRecordingUI()
                return
        }</span>

        // Generate filename with current timestamp
        <span class="cov0" title="0">now := time.Now()
        filename := fmt.Sprintf("recording_%s.wav", now.Format("20060102_1504"))

        // Save to input directory
        outputPath := filepath.Join(app.Config.InputDir, filename)
        err = app.recorder.SaveToFile(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(nil, &amp;app.logBuffer, &amp;app.logMutex, "録音ファイルの保存に失敗: %v", err)
                app.updateRecordingUI()
                return
        }</span>

        // KISS Design: Get duration directly from recorder
        <span class="cov0" title="0">duration := app.getRecordingDuration()
        logger.LogInfo(nil, &amp;app.logBuffer, &amp;app.logMutex, "録音を停止しました: %s (時間: %s)", filename, duration.Round(time.Second))

        // Update button appearance
        app.updateRecordingUI()</span>
}

// updateRecordingUI updates the recording-related UI elements
func (app *GUIApp) updateRecordingUI() <span class="cov0" title="0">{
        // Check if UI is ready and record button exists
        if !app.isUIReady() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">msg := ui.GetMessages(app.Config)
        // KISS Design: Direct query for current state
        isCurrentlyRecording := app.isRecording()
        
        // Use fyne.Do to safely update UI
        fyne.Do(func() </span><span class="cov0" title="0">{
                if isCurrentlyRecording </span><span class="cov0" title="0">{
                        app.recordButton.SetText("停止")
                        app.recordButton.Importance = widget.DangerImportance
                }</span> else<span class="cov0" title="0"> {
                        app.recordButton.SetText(msg.RecordCmd)
                        app.recordButton.Importance = widget.WarningImportance
                }</span>
                <span class="cov0" title="0">app.recordButton.Refresh()</span>
        })
}

// onQuitPressed handles the quit button press
func (app *GUIApp) onQuitPressed() <span class="cov0" title="0">{
        // KISS Design: Simple, consistent state check
        if app.isRecording() </span><span class="cov0" title="0">{
                // Show warning dialog if recording is in progress
                app.showRecordingExitWarning()
                return
        }</span>
        // Immediate exit if not recording
        <span class="cov0" title="0">app.forceQuit()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package gui

import (
        "fmt"
        "strconv"
        "time"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/widget"

        "github.com/hirokitakamura/koemoji-go/internal/config"
        "github.com/hirokitakamura/koemoji-go/internal/logger"
        "github.com/hirokitakamura/koemoji-go/internal/recorder"
)

// showConfigDialog displays the configuration dialog with tabbed interface
func (app *GUIApp) showConfigDialog() <span class="cov0" title="0">{
        // Create form entries for basic settings
        // UI Language first - most important setting
        uiLanguageSelect := widget.NewSelect([]string{"en", "ja"}, func(value string) </span>{<span class="cov0" title="0">
                // Handle UI language selection
        }</span>)
        <span class="cov0" title="0">uiLanguageSelect.SetSelected(app.Config.UILanguage)

        // Whisper model selection (dropdown)
        whisperModels := []string{
                "tiny", "tiny.en", "base", "base.en",
                "small", "small.en", "medium", "medium.en",
                "large", "large-v1", "large-v2", "large-v3",
        }
        whisperModelSelect := widget.NewSelect(whisperModels, nil)
        whisperModelSelect.SetSelected(app.Config.WhisperModel)

        // Language selection (dropdown)
        languages := []string{"ja", "en", "zh", "ko", "es", "fr", "de"}
        languageSelect := widget.NewSelect(languages, nil)
        languageSelect.SetSelected(app.Config.Language)

        scanIntervalEntry := widget.NewEntry()
        scanIntervalEntry.SetText(strconv.Itoa(app.Config.ScanIntervalMinutes))

        colorsCheck := widget.NewCheck("", nil)
        colorsCheck.SetChecked(app.Config.UseColors)

        // Basic settings form
        basicForm := widget.NewForm(
                widget.NewFormItem("言語", uiLanguageSelect),
                widget.NewFormItem("Whisperモデル", whisperModelSelect),
                widget.NewFormItem("音声認識言語", languageSelect),
                widget.NewFormItem("スキャン間隔（分）", scanIntervalEntry),
                widget.NewFormItem("色を使用", colorsCheck),
        )

        // Directory settings
        inputDirEntry := widget.NewEntry()
        inputDirEntry.SetText(app.Config.InputDir)

        outputDirEntry := widget.NewEntry()
        outputDirEntry.SetText(app.Config.OutputDir)

        archiveDirEntry := widget.NewEntry()
        archiveDirEntry.SetText(app.Config.ArchiveDir)

        dirForm := widget.NewForm(
                widget.NewFormItem("入力フォルダ", inputDirEntry),
                widget.NewFormItem("出力フォルダ", outputDirEntry),
                widget.NewFormItem("アーカイブフォルダ", archiveDirEntry),
        )

        // LLM settings
        llmEnabledCheck := widget.NewCheck("", nil)
        llmEnabledCheck.SetChecked(app.Config.LLMSummaryEnabled)

        llmAPIKeyEntry := widget.NewPasswordEntry()
        llmAPIKeyEntry.SetText(app.Config.LLMAPIKey)

        llmModelSelect := widget.NewSelect([]string{"gpt-4o", "gpt-4-turbo", "gpt-3.5-turbo"}, nil)
        llmModelSelect.SetSelected(app.Config.LLMModel)

        llmForm := widget.NewForm(
                widget.NewFormItem("AI要約を有効化", llmEnabledCheck),
                widget.NewFormItem("APIキー", llmAPIKeyEntry),
                widget.NewFormItem("モデル", llmModelSelect),
        )

        // Recording settings
        recordingForm := app.createRecordingForm()

        // Create tabs
        tabs := container.NewAppTabs(
                container.NewTabItem("基本設定", basicForm),
                container.NewTabItem("フォルダ設定", dirForm),
                container.NewTabItem("AI要約", llmForm),
                container.NewTabItem("録音設定", recordingForm),
        )

        // Create dialog content
        content := container.NewVBox(
                widget.NewLabel("KoeMoji-Go 設定"),
                tabs,
        )

        // Create dialog with Save/Cancel buttons
        configDialog := dialog.NewCustomConfirm("設定", "保存", "キャンセル", content,
                func(save bool) </span><span class="cov0" title="0">{
                        if save </span><span class="cov0" title="0">{
                                // Save configuration changes only when Save is clicked
                                app.saveConfigFromDialog(whisperModelSelect, languageSelect, uiLanguageSelect,
                                        scanIntervalEntry, colorsCheck, inputDirEntry, outputDirEntry,
                                        archiveDirEntry, llmEnabledCheck, llmAPIKeyEntry, llmModelSelect)
                        }</span>
                        // If Cancel is clicked, changes are discarded automatically
                }, app.window)
        <span class="cov0" title="0">configDialog.Resize(fyne.NewSize(600, 450))

        configDialog.Show()</span>
}

// createRecordingForm creates the recording settings form
func (app *GUIApp) createRecordingForm() *widget.Form <span class="cov0" title="0">{
        // Get available recording devices
        devices, err := recorder.ListDevices()
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(nil, &amp;app.logBuffer, &amp;app.logMutex, "Failed to list recording devices: %v", err)
                return widget.NewForm(
                        widget.NewFormItem("Error", widget.NewLabel("Failed to load recording devices")),
                )
        }</span>

        // Create device options
        <span class="cov0" title="0">var deviceNames []string
        var deviceMap = make(map[string]int)
        var selectedDevice string

        deviceNames = append(deviceNames, "Default Device")
        deviceMap["Default Device"] = -1
        selectedDevice = "Default Device"

        for _, device := range devices </span><span class="cov0" title="0">{
                deviceNames = append(deviceNames, device.Name)
                deviceMap[device.Name] = device.ID
                if device.ID == app.Config.RecordingDeviceID </span><span class="cov0" title="0">{
                        selectedDevice = device.Name
                }</span>
        }

        // If current device ID is -1, keep "Default Device" selected
        <span class="cov0" title="0">if app.Config.RecordingDeviceID == -1 </span><span class="cov0" title="0">{
                selectedDevice = "Default Device"
        }</span>

        // Create device selection widget
        <span class="cov0" title="0">deviceSelect := widget.NewSelect(deviceNames, nil)
        deviceSelect.SetSelected(selectedDevice)

        // Store reference for saving
        app.recordingDeviceSelect = deviceSelect
        app.recordingDeviceMap = deviceMap

        return widget.NewForm(
                widget.NewFormItem("録音デバイス", deviceSelect),
        )</span>
}

// saveConfigFromDialog saves the configuration from dialog form entries
func (app *GUIApp) saveConfigFromDialog(whisperModel, language *widget.Select,
        uiLanguage *widget.Select, scanInterval *widget.Entry, useColors *widget.Check,
        inputDir, outputDir, archiveDir *widget.Entry, llmEnabled *widget.Check,
        llmAPIKey *widget.Entry, llmModel *widget.Select) <span class="cov0" title="0">{

        // Update configuration
        app.Config.WhisperModel = whisperModel.Selected
        app.Config.Language = language.Selected
        app.Config.UILanguage = uiLanguage.Selected

        if interval, err := strconv.Atoi(scanInterval.Text); err == nil </span><span class="cov0" title="0">{
                app.Config.ScanIntervalMinutes = interval
        }</span>

        <span class="cov0" title="0">app.Config.UseColors = useColors.Checked
        app.Config.InputDir = inputDir.Text
        app.Config.OutputDir = outputDir.Text
        app.Config.ArchiveDir = archiveDir.Text
        app.Config.LLMSummaryEnabled = llmEnabled.Checked
        app.Config.LLMAPIKey = llmAPIKey.Text
        app.Config.LLMModel = llmModel.Selected

        // Update recording configuration
        if app.recordingDeviceSelect != nil &amp;&amp; app.recordingDeviceMap != nil </span><span class="cov0" title="0">{
                selectedDevice := app.recordingDeviceSelect.Selected
                if deviceID, exists := app.recordingDeviceMap[selectedDevice]; exists </span><span class="cov0" title="0">{
                        app.Config.RecordingDeviceID = deviceID
                        app.Config.RecordingDeviceName = selectedDevice
                }</span>
        }

        // Save to file
        <span class="cov0" title="0">if err := config.SaveConfig(app.Config, app.configPath); err != nil </span><span class="cov0" title="0">{
                logger.LogError(nil, &amp;app.logBuffer, &amp;app.logMutex, "Failed to save config: %v", err)
                dialog.ShowError(err, app.window)
        }</span> else<span class="cov0" title="0"> {
                logger.LogInfo(nil, &amp;app.logBuffer, &amp;app.logMutex, "Configuration saved successfully")
                dialog.ShowInformation("Success", "Configuration saved successfully!", app.window)
        }</span>
}

// showRecordingExitWarning shows a warning dialog when user tries to exit while recording
func (app *GUIApp) showRecordingExitWarning() <span class="cov0" title="0">{
        // KISS Design: Get duration directly from recorder
        elapsed := app.getRecordingDuration()

        // Create warning message with elapsed time
        warningMessage := fmt.Sprintf("録音中です（%s経過）\n録音データが失われますが終了しますか？",
                formatRecordingDuration(elapsed))

        // Create warning dialog
        confirmDialog := dialog.NewConfirm(
                "録音中",
                warningMessage,
                func(confirmed bool) </span><span class="cov0" title="0">{
                        if confirmed </span><span class="cov0" title="0">{
                                // User confirmed exit - force quit
                                app.forceQuit()
                        }</span>
                        // If not confirmed, dialog just closes and continues
                },
                app.window)

        <span class="cov0" title="0">confirmDialog.Show()</span>
}

// forceQuit performs immediate application exit with cleanup
func (app *GUIApp) forceQuit() <span class="cov0" title="0">{
        // Perform cleanup
        app.ForceCleanup()

        // Immediate exit - OS will handle whisper process termination
        app.fyneApp.Quit()
}</span>

// formatRecordingDuration formats a duration for display in recording dialog
func formatRecordingDuration(d time.Duration) string <span class="cov0" title="0">{
        hours := int(d.Hours())
        minutes := int(d.Minutes()) % 60
        seconds := int(d.Seconds()) % 60

        if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh%dm%ds", hours, minutes, seconds)
        }</span> else<span class="cov0" title="0"> if minutes &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm%ds", minutes, seconds)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%ds", seconds)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package icons

import (
        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/storage"
)

// GetAppIcon returns the application icon resource
func GetAppIcon() fyne.Resource <span class="cov0" title="0">{
        // For now, we'll use a simple placeholder
        // In the future, this can be replaced with a proper icon file
        // The icon should be embedded as a resource using fyne bundle

        // Return nil for now - Fyne will use a default icon
        return nil
}</span>

// GetIconURI returns the icon as a URI for window icon
func GetIconURI() fyne.URI <span class="cov0" title="0">{
        // Return nil for now - no custom icon file yet
        return storage.NewFileURI("icon.png") // placeholder
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package gui

import (
        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "fyne.io/fyne/v2/widget"

        "github.com/hirokitakamura/koemoji-go/internal/ui"
)

// createWindow creates and configures the main application window
func (app *GUIApp) createWindow() <span class="cov0" title="0">{
        // Create the main window
        app.window = app.fyneApp.NewWindow("KoeMoji-Go v1.3.0")
        app.window.Resize(fyne.NewSize(800, 700))
        app.window.CenterOnScreen()
        app.window.SetMaster()

        // Set window icon (will be implemented later)
        // app.window.SetIcon(resourceIconPng)

        // Create UI components
        app.createComponents()

        // Set up the main layout using BorderLayout
        content := container.NewBorder(
                app.statusWidget, // top
                app.buttonWidget, // bottom
                nil,              // left
                nil,              // right
                app.logWidget,    // center
        )

        app.window.SetContent(content)

        // Set up window close behavior with recording check
        app.window.SetCloseIntercept(func() </span><span class="cov0" title="0">{
                // KISS Design: Consistent state check across all exit points
                if app.isRecording() </span><span class="cov0" title="0">{
                        // Show warning dialog if recording is in progress
                        app.showRecordingExitWarning()
                        return
                }</span>
                // Immediate exit if not recording
                <span class="cov0" title="0">app.forceQuit()</span>
        })

        // Start periodic updates (5 seconds as per design)
        <span class="cov0" title="0">app.startPeriodicUpdate()</span>
}

// createComponents creates all UI components
func (app *GUIApp) createComponents() <span class="cov0" title="0">{
        // Get messages for the current language
        msg := ui.GetMessages(app.Config)

        // Create status panel (top)
        app.statusWidget = app.createStatusPanel(msg)

        // Create log viewer (center)
        app.logWidget = app.createLogViewer(msg)

        // Create button panel (bottom)
        app.buttonWidget = app.createButtonPanel(msg)

        // Mark UI as initialized
        app.uiInitialized = true
}</span>

// createStatusPanel creates the status display panel
func (app *GUIApp) createStatusPanel(msg *ui.Messages) fyne.CanvasObject <span class="cov0" title="0">{
        // Status line 1: Active/Processing state and queue info
        statusLabel := widget.NewLabel("🟢 " + msg.Active + " | " + msg.Queue + ": 0 | " + msg.Processing + ": " + msg.None)
        statusLabel.TextStyle = fyne.TextStyle{Bold: true}

        // Status line 2: File counts
        filesLabel := widget.NewLabel("📁 " + msg.Input + ": 0 → " + msg.Output + ": 0 → " + msg.Archive + ": 0")

        // Status line 3: Timing info
        timingLabel := widget.NewLabel("⏰ " + msg.Last + ": " + msg.Never + " | " + msg.Next + ": " + msg.Soon + " | " + msg.Uptime + ": 0s")

        // Store references for updates
        app.statusLabel = statusLabel
        app.filesLabel = filesLabel
        app.timingLabel = timingLabel

        // Create a card container for the status panel
        statusCard := widget.NewCard("", "", container.NewVBox(
                statusLabel,
                filesLabel,
                timingLabel,
        ))

        return statusCard
}</span>

// createLogViewer creates the scrollable log display
func (app *GUIApp) createLogViewer(msg *ui.Messages) fyne.CanvasObject <span class="cov0" title="0">{
        // Create a rich text widget for log display
        app.logText = widget.NewRichTextFromMarkdown("**Logs will appear here...**")
        app.logText.Wrapping = fyne.TextWrapWord

        // Create scrollable container
        logScroll := container.NewVScroll(app.logText)
        logScroll.SetMinSize(fyne.NewSize(750, 400))

        // Create a card container for the log viewer
        logCard := widget.NewCard("ログ", "", logScroll)

        return logCard
}</span>

// createButtonPanel creates the action buttons panel
func (app *GUIApp) createButtonPanel(msg *ui.Messages) fyne.CanvasObject <span class="cov0" title="0">{
        // Create buttons with localized labels
        configBtn := widget.NewButton(msg.ConfigCmd, func() </span><span class="cov0" title="0">{
                app.onConfigPressed()
        }</span>)
        <span class="cov0" title="0">configBtn.Importance = widget.MediumImportance

        logsBtn := widget.NewButton(msg.LogsCmd, func() </span><span class="cov0" title="0">{
                app.onLogsPressed()
        }</span>)

        <span class="cov0" title="0">scanBtn := widget.NewButton(msg.ScanCmd, func() </span><span class="cov0" title="0">{
                app.onScanPressed()
        }</span>)
        <span class="cov0" title="0">scanBtn.Importance = widget.HighImportance

        // Create recording button with dynamic text and importance
        recordBtn := widget.NewButton(msg.RecordCmd, func() </span><span class="cov0" title="0">{
                app.onRecordPressed()
        }</span>)
        <span class="cov0" title="0">recordBtn.Importance = widget.WarningImportance

        // Store reference for updating button text and appearance
        app.recordButton = recordBtn

        inputBtn := widget.NewButton(msg.InputDirCmd, func() </span><span class="cov0" title="0">{
                app.onInputDirPressed()
        }</span>)

        <span class="cov0" title="0">outputBtn := widget.NewButton(msg.OutputDirCmd, func() </span><span class="cov0" title="0">{
                app.onOutputDirPressed()
        }</span>)

        <span class="cov0" title="0">quitBtn := widget.NewButton(msg.QuitCmd, func() </span><span class="cov0" title="0">{
                app.onQuitPressed()
        }</span>)
        <span class="cov0" title="0">quitBtn.Importance = widget.DangerImportance

        // Create primary and secondary button groups for better organization
        primaryButtons := container.NewHBox(
                scanBtn,
                recordBtn,
        )

        configButtons := container.NewHBox(
                configBtn,
                logsBtn,
        )

        directoryButtons := container.NewHBox(
                inputBtn,
                outputBtn,
        )

        // Arrange buttons in a horizontal container with center alignment
        buttonContainer := container.NewHBox(
                layout.NewSpacer(), // 左側スペーサー
                primaryButtons,
                widget.NewSeparator(),
                configButtons,
                widget.NewSeparator(),
                directoryButtons,
                widget.NewSeparator(),
                quitBtn,
                layout.NewSpacer(), // 右側スペーサー
        )

        return buttonContainer</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package llm

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/hirokitakamura/koemoji-go/internal/config"
        "github.com/hirokitakamura/koemoji-go/internal/logger"
)

// OpenAI API structures
type OpenAIRequest struct {
        Model     string    `json:"model"`
        Messages  []Message `json:"messages"`
        MaxTokens int       `json:"max_tokens"`
}

type Message struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

type OpenAIResponse struct {
        Choices []Choice  `json:"choices"`
        Error   *APIError `json:"error,omitempty"`
}

type Choice struct {
        Message Message `json:"message"`
}

type APIError struct {
        Message string `json:"message"`
        Type    string `json:"type"`
        Code    string `json:"code"`
}

// SummarizeText generates a summary of the given text using LLM API
func SummarizeText(config *config.Config, log *log.Logger, logBuffer *[]logger.LogEntry,
        logMutex *sync.RWMutex, debugMode bool, text string) (string, error) <span class="cov0" title="0">{

        if !config.LLMSummaryEnabled </span><span class="cov0" title="0">{
                return "", fmt.Errorf("LLM summary is disabled")
        }</span>

        <span class="cov0" title="0">if config.LLMAPIKey == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("LLM API key is not configured")
        }</span>

        // Prepare prompt
        <span class="cov0" title="0">prompt := preparePrompt(config, text)

        // Call API based on provider
        switch config.LLMAPIProvider </span>{
        case "openai":<span class="cov0" title="0">
                return callOpenAI(config, log, logBuffer, logMutex, debugMode, prompt)</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported LLM provider: %s", config.LLMAPIProvider)</span>
        }
}

func preparePrompt(config *config.Config, text string) string <span class="cov0" title="0">{
        prompt := config.SummaryPromptTemplate

        // Replace variables in template
        language := getSummaryLanguage(config)
        prompt = strings.ReplaceAll(prompt, "{text}", text)
        prompt = strings.ReplaceAll(prompt, "{language}", language)

        return prompt
}</span>

func getSummaryLanguage(config *config.Config) string <span class="cov0" title="0">{
        switch config.SummaryLanguage </span>{
        case "auto":<span class="cov0" title="0">
                // Use the same language as the transcription
                if config.Language == "ja" </span><span class="cov0" title="0">{
                        return "日本語"
                }</span>
                <span class="cov0" title="0">return "英語"</span>
        case "ja":<span class="cov0" title="0">
                return "日本語"</span>
        case "en":<span class="cov0" title="0">
                return "英語"</span>
        default:<span class="cov0" title="0">
                return "日本語"</span>
        }
}

func callOpenAI(config *config.Config, log *log.Logger, logBuffer *[]logger.LogEntry,
        logMutex *sync.RWMutex, debugMode bool, prompt string) (string, error) <span class="cov0" title="0">{

        // Prepare request
        request := OpenAIRequest{
                Model:     config.LLMModel,
                MaxTokens: config.LLMMaxTokens,
                Messages: []Message{
                        {
                                Role:    "user",
                                Content: prompt,
                        },
                },
        }

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">logger.LogDebug(log, logBuffer, logMutex, debugMode, "OpenAI API request prepared")

        // Create HTTP request
        req, err := http.NewRequest("POST", "https://api.openai.com/v1/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+config.LLMAPIKey)

        // Make request with retry logic
        var response *http.Response
        maxRetries := 3
        for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                client := &amp;http.Client{
                        Timeout: 5 * time.Minute,
                }

                response, err = client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(log, logBuffer, logMutex, "OpenAI API request failed (attempt %d/%d): %v", attempt, maxRetries, err)
                        if attempt &lt; maxRetries </span><span class="cov0" title="0">{
                                time.Sleep(time.Duration(attempt) * 10 * time.Second)
                                continue</span>
                        }
                        <span class="cov0" title="0">return "", fmt.Errorf("failed to call OpenAI API after %d attempts: %w", maxRetries, err)</span>
                }

                <span class="cov0" title="0">if response.StatusCode == 429 </span><span class="cov0" title="0">{
                        // Rate limit hit
                        logger.LogInfo(log, logBuffer, logMutex, "Rate limit hit, waiting 60 seconds...")
                        response.Body.Close()
                        if attempt &lt; maxRetries </span><span class="cov0" title="0">{
                                time.Sleep(60 * time.Second)
                                continue</span>
                        }
                }

                <span class="cov0" title="0">break</span>
        }
        <span class="cov0" title="0">defer response.Body.Close()

        // Read response
        body, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">logger.LogDebug(log, logBuffer, logMutex, debugMode, "OpenAI API response received (status: %d)", response.StatusCode)

        // Parse response
        var apiResponse OpenAIResponse
        if err := json.Unmarshal(body, &amp;apiResponse); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse response: %w", err)
        }</span>

        // Check for API errors
        <span class="cov0" title="0">if apiResponse.Error != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("OpenAI API error: %s", apiResponse.Error.Message)
        }</span>

        <span class="cov0" title="0">if len(apiResponse.Choices) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no response from OpenAI API")
        }</span>

        <span class="cov0" title="0">summary := apiResponse.Choices[0].Message.Content
        logger.LogDebug(log, logBuffer, logMutex, debugMode, "Summary generated successfully (%d characters)", len(summary))

        return summary, nil</span>
}

// ValidateAPIKey tests the API key by making a simple request
func ValidateAPIKey(config *config.Config) error <span class="cov8" title="1">{
        if config.LLMAPIKey == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("API key is empty")
        }</span>

        // Simple test request
        <span class="cov8" title="1">request := OpenAIRequest{
                Model:     "gpt-3.5-turbo",
                MaxTokens: 1,
                Messages: []Message{
                        {
                                Role:    "user",
                                Content: "Test",
                        },
                },
        }

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal test request: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", "https://api.openai.com/v1/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create test request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+config.LLMAPIKey)

        client := &amp;http.Client{
                Timeout: 30 * time.Second,
        }

        response, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to test API key: %w", err)
        }</span>
        <span class="cov8" title="1">defer response.Body.Close()

        if response.StatusCode == 401 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid API key")
        }</span>

        <span class="cov0" title="0">if response.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(response.Body)
                return fmt.Errorf("API test failed with status %d: %s", response.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package logger

import (
        "fmt"
        "log"
        "sync"
        "time"
)

type LogEntry struct {
        Level     string
        Message   string
        Timestamp time.Time
}

// Logging functions
func addToLogBuffer(logBuffer *[]LogEntry, logMutex *sync.RWMutex, level, message string) <span class="cov0" title="0">{
        logMutex.Lock()
        defer logMutex.Unlock()

        entry := LogEntry{
                Level:     level,
                Message:   message,
                Timestamp: time.Now(),
        }

        *logBuffer = append(*logBuffer, entry)
        if len(*logBuffer) &gt; 12 </span><span class="cov0" title="0">{
                *logBuffer = (*logBuffer)[1:]
        }</span>
}

func LogInfo(logger *log.Logger, logBuffer *[]LogEntry, logMutex *sync.RWMutex, format string, v ...any) <span class="cov0" title="0">{
        message := fmt.Sprintf(format, v...)
        if logger != nil </span><span class="cov0" title="0">{
                logger.Printf("[INFO] %s", message)
        }</span>
        <span class="cov0" title="0">addToLogBuffer(logBuffer, logMutex, "INFO", message)</span>
}

func LogError(logger *log.Logger, logBuffer *[]LogEntry, logMutex *sync.RWMutex, format string, v ...any) <span class="cov0" title="0">{
        message := fmt.Sprintf(format, v...)
        if logger != nil </span><span class="cov0" title="0">{
                logger.Printf("[ERROR] %s", message)
        }</span>
        <span class="cov0" title="0">addToLogBuffer(logBuffer, logMutex, "ERROR", message)</span>
}

func LogDebug(logger *log.Logger, logBuffer *[]LogEntry, logMutex *sync.RWMutex, debugMode bool, format string, v ...any) <span class="cov0" title="0">{
        if debugMode </span><span class="cov0" title="0">{
                message := fmt.Sprintf(format, v...)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Printf("[DEBUG] %s", message)
                }</span>
                <span class="cov0" title="0">addToLogBuffer(logBuffer, logMutex, "DEBUG", message)</span>
        }
}

func LogProc(logger *log.Logger, logBuffer *[]LogEntry, logMutex *sync.RWMutex, format string, v ...any) <span class="cov0" title="0">{
        message := fmt.Sprintf(format, v...)
        if logger != nil </span><span class="cov0" title="0">{
                logger.Printf("[PROC] %s", message)
        }</span>
        <span class="cov0" title="0">addToLogBuffer(logBuffer, logMutex, "PROC", message)</span>
}

func LogDone(logger *log.Logger, logBuffer *[]LogEntry, logMutex *sync.RWMutex, format string, v ...any) <span class="cov0" title="0">{
        message := fmt.Sprintf(format, v...)
        if logger != nil </span><span class="cov0" title="0">{
                logger.Printf("[DONE] %s", message)
        }</span>
        <span class="cov0" title="0">addToLogBuffer(logBuffer, logMutex, "DONE", message)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package processor

import (
        "context"
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/hirokitakamura/koemoji-go/internal/config"
        "github.com/hirokitakamura/koemoji-go/internal/llm"
        "github.com/hirokitakamura/koemoji-go/internal/logger"
        "github.com/hirokitakamura/koemoji-go/internal/ui"
        "github.com/hirokitakamura/koemoji-go/internal/whisper"
)

func StartProcessing(ctx context.Context, config *config.Config, log *log.Logger, logBuffer *[]logger.LogEntry, logMutex *sync.RWMutex,
        lastScanTime *time.Time, queuedFiles *[]string, processingFile *string, isProcessing *bool,
        processedFiles *map[string]bool, mu *sync.Mutex, wg *sync.WaitGroup, debugMode bool) <span class="cov0" title="0">{

        // Initial scan
        ScanAndProcess(config, log, logBuffer, logMutex, lastScanTime, queuedFiles, processingFile,
                isProcessing, processedFiles, mu, wg, debugMode)

        // Periodic scan with context cancellation
        ticker := time.NewTicker(time.Duration(config.ScanIntervalMinutes) * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.LogInfo(log, logBuffer, logMutex, "File processing stopped by context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ScanAndProcess(config, log, logBuffer, logMutex, lastScanTime, queuedFiles, processingFile,
                                isProcessing, processedFiles, mu, wg, debugMode)</span>
                }
        }
}

func ScanAndProcess(config *config.Config, log *log.Logger, logBuffer *[]logger.LogEntry, logMutex *sync.RWMutex,
        lastScanTime *time.Time, queuedFiles *[]string, processingFile *string, isProcessing *bool,
        processedFiles *map[string]bool, mu *sync.Mutex, wg *sync.WaitGroup, debugMode bool) <span class="cov0" title="0">{

        *lastScanTime = time.Now()
        msg := ui.GetMessages(config)
        logger.LogInfo(log, logBuffer, logMutex, msg.ScanningDir)

        files, err := filepath.Glob(filepath.Join(config.InputDir, "*"))
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(log, logBuffer, logMutex, "Failed to scan input directory: %v", err)
                return
        }</span>

        <span class="cov0" title="0">newFiles := filterNewAudioFiles(files, processedFiles, mu)
        if len(newFiles) == 0 </span><span class="cov0" title="0">{
                logger.LogDebug(log, logBuffer, logMutex, debugMode, "No new files found")
                return
        }</span>

        <span class="cov0" title="0">logger.LogInfo(log, logBuffer, logMutex, msg.FoundFiles, len(newFiles))

        // Add files to queue
        mu.Lock()
        *queuedFiles = append(*queuedFiles, newFiles...)
        
        // Phase 1: Periodic cleanup of processed files map
        if len(*processedFiles) &gt; 5000 </span><span class="cov0" title="0">{
                cleanupProcessedFiles(processedFiles, log, logBuffer, logMutex)
        }</span>
        <span class="cov0" title="0">mu.Unlock()

        // Start processing if not already processing
        if !*isProcessing </span><span class="cov0" title="0">{
                if wg != nil </span><span class="cov0" title="0">{
                        wg.Add(1)
                }</span>
                <span class="cov0" title="0">go processQueue(config, log, logBuffer, logMutex, queuedFiles, processingFile,
                        isProcessing, mu, wg, debugMode)</span>
        }
}

func filterNewAudioFiles(files []string, processedFiles *map[string]bool, mu *sync.Mutex) []string <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()

        var newFiles []string
        for _, file := range files </span><span class="cov0" title="0">{
                if ui.IsAudioFile(file) &amp;&amp; !(*processedFiles)[file] </span><span class="cov0" title="0">{
                        (*processedFiles)[file] = true
                        newFiles = append(newFiles, file)
                }</span>
        }
        <span class="cov0" title="0">return newFiles</span>
}

func processQueue(config *config.Config, log *log.Logger, logBuffer *[]logger.LogEntry, logMutex *sync.RWMutex,
        queuedFiles *[]string, processingFile *string, isProcessing *bool, mu *sync.Mutex,
        wg *sync.WaitGroup, debugMode bool) <span class="cov0" title="0">{

        defer func() </span><span class="cov0" title="0">{
                if wg != nil </span><span class="cov0" title="0">{
                        wg.Done()
                }</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                mu.Lock()
                if len(*queuedFiles) == 0 </span><span class="cov0" title="0">{
                        *isProcessing = false
                        *processingFile = ""
                        mu.Unlock()
                        return
                }</span>

                // Get next file from queue
                <span class="cov0" title="0">filePath := (*queuedFiles)[0]
                *queuedFiles = (*queuedFiles)[1:]
                *processingFile = filepath.Base(filePath)
                *isProcessing = true
                mu.Unlock()

                // Process the file
                msg := ui.GetMessages(config)
                logger.LogProc(log, logBuffer, logMutex, msg.ProcessingFile, *processingFile)
                startTime := time.Now()

                if err := whisper.TranscribeAudio(config, log, logBuffer, logMutex, debugMode, filePath); err != nil </span><span class="cov0" title="0">{
                        logger.LogError(log, logBuffer, logMutex, msg.ProcessFailed, *processingFile, err)
                }</span> else<span class="cov0" title="0"> {
                        duration := time.Since(startTime)
                        logger.LogDone(log, logBuffer, logMutex, msg.ProcessComplete, *processingFile, formatDuration(duration))

                        // Generate summary if enabled
                        if config.LLMSummaryEnabled </span><span class="cov0" title="0">{
                                if err := generateSummary(config, log, logBuffer, logMutex, debugMode, filePath); err != nil </span><span class="cov0" title="0">{
                                        logger.LogError(log, logBuffer, logMutex, "Summary generation failed for %s: %v", *processingFile, err)
                                }</span>
                        }

                        // Move to archive
                        <span class="cov0" title="0">msg2 := ui.GetMessages(config)
                        logger.LogProc(log, logBuffer, logMutex, msg2.MovingToArchive, *processingFile)
                        if err := moveToArchive(config, filePath); err != nil </span><span class="cov0" title="0">{
                                logger.LogError(log, logBuffer, logMutex, msg.ProcessFailed, *processingFile, err)
                        }</span>
                }
        }
}

func moveToArchive(config *config.Config, sourcePath string) error <span class="cov0" title="0">{
        filename := filepath.Base(sourcePath)
        destPath := filepath.Join(config.ArchiveDir, filename)

        // Handle duplicate filenames
        if _, err := os.Stat(destPath); err == nil </span><span class="cov0" title="0">{
                timestamp := time.Now().Format("20060102_150405")
                ext := filepath.Ext(filename)
                name := strings.TrimSuffix(filename, ext)
                destPath = filepath.Join(config.ArchiveDir, fmt.Sprintf("%s_%s%s", name, timestamp, ext))
        }</span>

        <span class="cov0" title="0">if err := os.Rename(sourcePath, destPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func EnsureDirectories(config *config.Config, log *log.Logger) <span class="cov8" title="1">{
        dirs := []string{config.InputDir, config.OutputDir, config.ArchiveDir}
        for _, dir := range dirs </span><span class="cov8" title="1">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        msg := ui.GetMessages(config)
                        log.Printf("[ERROR] "+msg.DirCreateError, dir, err)
                        os.Exit(1)
                }</span>
        }
}

func generateSummary(config *config.Config, log *log.Logger, logBuffer *[]logger.LogEntry,
        logMutex *sync.RWMutex, debugMode bool, originalFilePath string) error <span class="cov0" title="0">{

        // Find the corresponding transcription file
        basename := strings.TrimSuffix(filepath.Base(originalFilePath), filepath.Ext(originalFilePath))
        transcriptionFile := filepath.Join(config.OutputDir, basename+"."+config.OutputFormat)

        // Check if transcription file exists
        if _, err := os.Stat(transcriptionFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("transcription file not found: %s", transcriptionFile)
        }</span>

        <span class="cov0" title="0">logger.LogProc(log, logBuffer, logMutex, "Generating summary for %s...", basename)

        // Read transcription content
        content, err := readTranscriptionFile(transcriptionFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read transcription file: %w", err)
        }</span>

        // Generate summary using LLM
        <span class="cov0" title="0">summary, err := llm.SummarizeText(config, log, logBuffer, logMutex, debugMode, content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate summary: %w", err)
        }</span>

        // Save summary to file
        <span class="cov0" title="0">summaryFile := filepath.Join(config.OutputDir, basename+"_summary.txt")
        if err := saveSummaryFile(summaryFile, summary); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save summary: %w", err)
        }</span>

        <span class="cov0" title="0">logger.LogDone(log, logBuffer, logMutex, "Summary saved to %s", filepath.Base(summaryFile))
        return nil</span>
}

func readTranscriptionFile(filePath string) (string, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        content, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(content), nil</span>
}

func saveSummaryFile(filePath, summary string) error <span class="cov0" title="0">{
        file, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        _, err = file.WriteString(summary)
        return err</span>
}

func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        hours := int(d.Hours())
        minutes := int(d.Minutes()) % 60
        seconds := int(d.Seconds()) % 60

        if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh%dm%ds", hours, minutes, seconds)
        }</span> else<span class="cov0" title="0"> if minutes &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm%ds", minutes, seconds)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%ds", seconds)
        }</span>
}

// Phase 1: Helper function for processed files cleanup
func cleanupProcessedFiles(processedFiles *map[string]bool, log *log.Logger, logBuffer *[]logger.LogEntry, logMutex *sync.RWMutex) <span class="cov0" title="0">{
        // Keep only the most recent 2500 entries (half of the threshold)
        if len(*processedFiles) &lt;= 2500 </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Simple approach: reset the map when it gets too large
        // In a production system, you might want to keep recent entries based on timestamp
        <span class="cov0" title="0">newMap := make(map[string]bool)
        count := 0
        
        // Keep approximately half of the entries
        for file := range *processedFiles </span><span class="cov0" title="0">{
                if count &lt; 2500 </span><span class="cov0" title="0">{
                        newMap[file] = true
                        count++
                }</span>
        }
        
        <span class="cov0" title="0">*processedFiles = newMap
        logger.LogInfo(log, logBuffer, logMutex, "Cleaned up processed files map, kept %d entries", len(*processedFiles))</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package recorder

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "os"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/gordonklaus/portaudio"
)

const (
        SampleRate = 44100
        Channels   = 1
        BufferSize = 4096
        // Phase 1: Memory-efficient recording with buffering
        MemoryBufferSize = 88200 * 5  // 5 seconds worth of samples (44.1kHz * 2bytes * 5sec)
        FlushThreshold   = 88200 * 2  // Flush every 2 seconds
)

type DeviceInfo struct {
        ID          int
        Name        string
        IsDefault   bool
        MaxChannels int
        HostAPI     string
        IsVirtual   bool
        VirtualType string
}

type Recorder struct {
        stream     *portaudio.Stream
        samples    []int16          // Memory buffer (limited size)
        recording  bool
        sampleRate float64
        deviceInfo *portaudio.DeviceInfo
        mutex      sync.Mutex
        startTime  time.Time
        
        // Phase 1: Memory-efficient recording
        tempFile     *os.File        // Temporary file for overflow
        totalSamples int64           // Total samples written
        lastFlush    time.Time       // Last flush time
        maxDuration  time.Duration   // Maximum recording duration (0 = unlimited)
        maxFileSize  int64          // Maximum file size in bytes (0 = unlimited)
}

func NewRecorder() (*Recorder, error) <span class="cov8" title="1">{
        err := portaudio.Initialize()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Recorder{
                samples:      make([]int16, 0, MemoryBufferSize),
                recording:    false,
                sampleRate:   SampleRate,
                maxDuration:  0,  // Unlimited by default
                maxFileSize:  0,  // Unlimited by default
        }, nil</span>
}

func NewRecorderWithDevice(deviceID int) (*Recorder, error) <span class="cov0" title="0">{
        err := portaudio.Initialize()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">devices, err := portaudio.Devices()
        if err != nil </span><span class="cov0" title="0">{
                portaudio.Terminate()
                return nil, err
        }</span>

        <span class="cov0" title="0">var selectedDevice *portaudio.DeviceInfo
        for _, device := range devices </span><span class="cov0" title="0">{
                if device.Index == deviceID &amp;&amp; device.MaxInputChannels &gt; 0 </span><span class="cov0" title="0">{
                        selectedDevice = device
                        break</span>
                }
        }

        <span class="cov0" title="0">if selectedDevice == nil </span><span class="cov0" title="0">{
                portaudio.Terminate()
                return nil, fmt.Errorf("device not found or has no input channels: index %d", deviceID)
        }</span>

        <span class="cov0" title="0">return &amp;Recorder{
                samples:      make([]int16, 0, MemoryBufferSize),
                recording:    false,
                sampleRate:   SampleRate,
                deviceInfo:   selectedDevice,
                maxDuration:  0,  // Unlimited by default
                maxFileSize:  0,  // Unlimited by default
        }, nil</span>
}

func (r *Recorder) Start() error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if r.recording </span><span class="cov8" title="1">{
                return errors.New("recording already in progress")
        }</span>

        <span class="cov8" title="1">r.samples = make([]int16, 0, MemoryBufferSize)
        r.startTime = time.Now()
        r.lastFlush = time.Now()
        r.totalSamples = 0
        
        // Create temporary file for overflow data
        if r.tempFile != nil </span><span class="cov0" title="0">{
                r.tempFile.Close()
                r.tempFile = nil
        }</span>

        <span class="cov8" title="1">var stream *portaudio.Stream
        var err error

        if r.deviceInfo != nil </span><span class="cov0" title="0">{
                params := portaudio.StreamParameters{
                        Input: portaudio.StreamDeviceParameters{
                                Device:   r.deviceInfo,
                                Channels: Channels,
                                Latency:  r.deviceInfo.DefaultLowInputLatency,
                        },
                        SampleRate:      r.sampleRate,
                        FramesPerBuffer: BufferSize,
                }
                stream, err = portaudio.OpenStream(params, r.recordCallback)
        }</span> else<span class="cov8" title="1"> {
                stream, err = portaudio.OpenDefaultStream(
                        Channels,
                        0,
                        r.sampleRate,
                        BufferSize,
                        r.recordCallback,
                )
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = stream.Start()
        if err != nil </span><span class="cov0" title="0">{
                stream.Close()
                return err
        }</span>

        <span class="cov8" title="1">r.stream = stream
        r.recording = true
        return nil</span>
}

func (r *Recorder) recordCallback(in []int16) <span class="cov0" title="0">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if !r.recording </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Check recording limits
        <span class="cov0" title="0">if r.exceedsLimits() </span><span class="cov0" title="0">{
                r.recording = false
                return
        }</span>
        
        // Add samples to memory buffer
        <span class="cov0" title="0">r.samples = append(r.samples, in...)
        r.totalSamples += int64(len(in))
        
        // Check if buffer needs flushing
        if len(r.samples) &gt;= FlushThreshold || time.Since(r.lastFlush) &gt; 2*time.Second </span><span class="cov0" title="0">{
                r.flushToTempFile()
        }</span>
}

func (r *Recorder) Stop() error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if !r.recording </span><span class="cov8" title="1">{
                return errors.New("no recording in progress")
        }</span>

        <span class="cov8" title="1">err := r.stream.Stop()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = r.stream.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Final flush of remaining samples
        <span class="cov8" title="1">if len(r.samples) &gt; 0 </span><span class="cov0" title="0">{
                r.flushToTempFile()
        }</span>

        <span class="cov8" title="1">r.recording = false
        r.stream = nil
        return nil</span>
}

func (r *Recorder) SaveToFile(filename string) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if r.totalSamples == 0 </span><span class="cov8" title="1">{
                return errors.New("no audio data to save")
        }</span>

        // If we have a temp file, consolidate all data
        <span class="cov0" title="0">if r.tempFile != nil </span><span class="cov0" title="0">{
                return r.consolidateToFile(filename)
        }</span>
        
        // If only memory samples, use existing method
        <span class="cov0" title="0">if len(r.samples) == 0 </span><span class="cov0" title="0">{
                return errors.New("no audio data to save")
        }</span>

        <span class="cov0" title="0">return SaveWAV(filename, r.samples, int(r.sampleRate), Channels)</span>
}

func (r *Recorder) Close() error <span class="cov8" title="1">{
        if r.recording </span><span class="cov0" title="0">{
                err := r.Stop()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        // Clean up temp file
        <span class="cov8" title="1">if r.tempFile != nil </span><span class="cov0" title="0">{
                r.tempFile.Close()
                os.Remove(r.tempFile.Name())  // Remove temp file
                r.tempFile = nil
        }</span>

        <span class="cov8" title="1">portaudio.Terminate()
        return nil</span>
}

func (r *Recorder) IsRecording() bool <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()
        return r.recording
}</span>

func (r *Recorder) GetDuration() float64 <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()
        return float64(r.totalSamples) / r.sampleRate
}</span>

func (r *Recorder) GetElapsedTime() time.Duration <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()
        if r.recording </span><span class="cov8" title="1">{
                return time.Since(r.startTime)
        }</span>
        <span class="cov8" title="1">return 0</span>
}

func detectVirtualDevice(device *portaudio.DeviceInfo) (bool, string) <span class="cov8" title="1">{
        name := strings.ToLower(device.Name)

        switch runtime.GOOS </span>{
        case "darwin":<span class="cov8" title="1">
                if strings.Contains(name, "blackhole") </span><span class="cov8" title="1">{
                        return true, "BlackHole"
                }</span>
                <span class="cov8" title="1">if strings.Contains(name, "aggregate") || strings.Contains(name, "集約") </span><span class="cov0" title="0">{
                        return true, "Aggregate"
                }</span>
                <span class="cov8" title="1">if strings.Contains(name, "multi-output") || strings.Contains(name, "マルチ出力") </span><span class="cov0" title="0">{
                        return true, "Multi-Output"
                }</span>
        case "windows":<span class="cov0" title="0">
                if strings.Contains(name, "stereo mix") ||
                        strings.Contains(name, "what u hear") ||
                        strings.Contains(name, "rec. playback") </span><span class="cov0" title="0">{
                        return true, "Stereo Mix"
                }</span>
        }

        <span class="cov8" title="1">return false, ""</span>
}

func ListDevices() ([]DeviceInfo, error) <span class="cov8" title="1">{
        err := portaudio.Initialize()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer portaudio.Terminate()

        devices, err := portaudio.Devices()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defaultInput, err := portaudio.DefaultInputDevice()
        if err != nil </span><span class="cov0" title="0">{
                defaultInput = nil
        }</span>

        <span class="cov8" title="1">var deviceList []DeviceInfo
        for _, device := range devices </span><span class="cov8" title="1">{
                if device.MaxInputChannels &gt; 0 </span><span class="cov8" title="1">{
                        isVirtual, virtualType := detectVirtualDevice(device)
                        isDefault := defaultInput != nil &amp;&amp; device.Index == defaultInput.Index

                        deviceInfo := DeviceInfo{
                                ID:          device.Index,
                                Name:        device.Name,
                                IsDefault:   isDefault,
                                MaxChannels: device.MaxInputChannels,
                                HostAPI:     device.HostApi.Name,
                                IsVirtual:   isVirtual,
                                VirtualType: virtualType,
                        }
                        deviceList = append(deviceList, deviceInfo)
                }</span>
        }

        <span class="cov8" title="1">return deviceList, nil</span>
}

// Phase 1: Memory-efficient recording helper methods

// exceedsLimits checks if recording limits are exceeded
func (r *Recorder) exceedsLimits() bool <span class="cov0" title="0">{
        // Check duration limit
        if r.maxDuration &gt; 0 &amp;&amp; time.Since(r.startTime) &gt;= r.maxDuration </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Check file size limit (approximate)
        <span class="cov0" title="0">if r.maxFileSize &gt; 0 </span><span class="cov0" title="0">{
                estimatedSize := r.totalSamples * 2 + 44 // 2 bytes per sample + WAV header
                if estimatedSize &gt;= r.maxFileSize </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

// flushToTempFile flushes memory samples to temporary file
func (r *Recorder) flushToTempFile() error <span class="cov0" title="0">{
        if len(r.samples) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Create temp file if it doesn't exist
        <span class="cov0" title="0">if r.tempFile == nil </span><span class="cov0" title="0">{
                tempFile, err := os.CreateTemp("", "koemoji_recording_*.raw")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">r.tempFile = tempFile</span>
        }
        
        // Write samples to temp file as raw bytes
        <span class="cov0" title="0">err := binary.Write(r.tempFile, binary.LittleEndian, r.samples)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Clear memory buffer but preserve capacity
        <span class="cov0" title="0">r.samples = r.samples[:0]
        r.lastFlush = time.Now()
        
        return nil</span>
}

// consolidateToFile combines temp file and memory buffer into final WAV file
func (r *Recorder) consolidateToFile(filename string) error <span class="cov0" title="0">{
        // Create output file
        outFile, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer outFile.Close()
        
        // Calculate total data size
        dataSize := r.totalSamples * 2 // 2 bytes per sample
        fileSize := 36 + dataSize
        
        // Write WAV header
        header := WAVHeader{
                ChunkID:       [4]byte{'R', 'I', 'F', 'F'},
                ChunkSize:     uint32(fileSize),
                Format:        [4]byte{'W', 'A', 'V', 'E'},
                Subchunk1ID:   [4]byte{'f', 'm', 't', ' '},
                Subchunk1Size: 16,
                AudioFormat:   1, // PCM
                NumChannels:   uint16(Channels),
                SampleRate:    uint32(r.sampleRate),
                ByteRate:      uint32(r.sampleRate * Channels * 16 / 8),
                BlockAlign:    uint16(Channels * 16 / 8),
                BitsPerSample: 16,
                Subchunk2ID:   [4]byte{'d', 'a', 't', 'a'},
                Subchunk2Size: uint32(dataSize),
        }
        
        err = binary.Write(outFile, binary.LittleEndian, header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Copy temp file data if it exists
        <span class="cov0" title="0">if r.tempFile != nil </span><span class="cov0" title="0">{
                r.tempFile.Seek(0, 0) // Seek to beginning
                _, err = io.Copy(outFile, r.tempFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        // Write remaining memory samples
        <span class="cov0" title="0">if len(r.samples) &gt; 0 </span><span class="cov0" title="0">{
                err = binary.Write(outFile, binary.LittleEndian, r.samples)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// SetLimits configures recording limits
func (r *Recorder) SetLimits(maxDuration time.Duration, maxFileSize int64) <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()
        r.maxDuration = maxDuration
        r.maxFileSize = maxFileSize
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package recorder

import (
        "encoding/binary"
        "os"
)

type WAVHeader struct {
        ChunkID       [4]byte
        ChunkSize     uint32
        Format        [4]byte
        Subchunk1ID   [4]byte
        Subchunk1Size uint32
        AudioFormat   uint16
        NumChannels   uint16
        SampleRate    uint32
        ByteRate      uint32
        BlockAlign    uint16
        BitsPerSample uint16
        Subchunk2ID   [4]byte
        Subchunk2Size uint32
}

func SaveWAV(filename string, samples []int16, sampleRate, channels int) error <span class="cov0" title="0">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        bitsPerSample := 16
        dataSize := len(samples) * 2
        fileSize := 36 + dataSize

        header := WAVHeader{
                ChunkID:       [4]byte{'R', 'I', 'F', 'F'},
                ChunkSize:     uint32(fileSize),
                Format:        [4]byte{'W', 'A', 'V', 'E'},
                Subchunk1ID:   [4]byte{'f', 'm', 't', ' '},
                Subchunk1Size: 16,
                AudioFormat:   1, // PCM
                NumChannels:   uint16(channels),
                SampleRate:    uint32(sampleRate),
                ByteRate:      uint32(sampleRate * channels * bitsPerSample / 8),
                BlockAlign:    uint16(channels * bitsPerSample / 8),
                BitsPerSample: uint16(bitsPerSample),
                Subchunk2ID:   [4]byte{'d', 'a', 't', 'a'},
                Subchunk2Size: uint32(dataSize),
        }

        err = binary.Write(file, binary.LittleEndian, header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Write(file, binary.LittleEndian, samples)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package ui

import "github.com/hirokitakamura/koemoji-go/internal/config"

// Messages contains all UI text strings
type Messages struct {
        // Main UI
        Active     string
        Processing string
        Queue      string
        None       string
        Input      string
        Output     string
        Archive    string
        Last       string
        Next       string
        Never      string
        Soon       string
        Uptime     string

        // Commands
        ConfigCmd    string
        LogsCmd      string
        ScanCmd      string
        QuitCmd      string
        InputDirCmd  string
        OutputDirCmd string
        RecordCmd    string

        // Log levels
        LogInfo  string
        LogProc  string
        LogDone  string
        LogError string
        LogDebug string

        // Processing messages
        AppStarted      string
        AppRunning      string
        MonitoringDir   string
        ShuttingDown    string
        ScanningDir     string
        FoundFiles      string
        ProcessingFile  string
        ProcessComplete string
        ProcessFailed   string
        MovingToArchive string

        // Error messages
        LogFileError    string
        ConfigLoadError string
        ConfigSaveError string
        DirCreateError  string
        DirNotExist     string
        FileNotFound    string
        InvalidPath     string
        TranscribeFail  string
        UnsupportedOS   string

        // Recording messages
        RecordingDevice string
        Recording       string
        RecordingStop   string
        SelectDevice    string
}

var messagesEN = Messages{
        // Main UI
        Active:     "Active",
        Processing: "Processing",
        Queue:      "Queue",
        None:       "None",
        Input:      "Input",
        Output:     "Output",
        Archive:    "Archive",
        Last:       "Last",
        Next:       "Next",
        Never:      "Never",
        Soon:       "Soon",
        Uptime:     "Uptime",

        // Commands
        ConfigCmd:    "config",
        LogsCmd:      "logs",
        ScanCmd:      "scan",
        QuitCmd:      "quit",
        InputDirCmd:  "input",
        OutputDirCmd: "output",
        RecordCmd:    "record",

        // Log levels
        LogInfo:  "INFO",
        LogProc:  "PROC",
        LogDone:  "DONE",
        LogError: "ERROR",
        LogDebug: "DEBUG",

        // Processing messages
        AppStarted:      "KoeMoji-Go v%s started",
        AppRunning:      "KoeMoji-Go is running. Use commands below to interact.",
        MonitoringDir:   "Monitoring %s directory every %d minutes",
        ShuttingDown:    "Shutting down KoeMoji-Go...",
        ScanningDir:     "Scanning directory for audio files...",
        FoundFiles:      "Found %d audio files to process",
        ProcessingFile:  "Processing %s",
        ProcessComplete: "Completed %s in %s",
        ProcessFailed:   "Failed to process %s: %v",
        MovingToArchive: "Moving %s to archive",

        // Error messages
        LogFileError:    "Failed to open log file: %v",
        ConfigLoadError: "Failed to load config: %v",
        ConfigSaveError: "Failed to save config: %v",
        DirCreateError:  "Failed to create directory %s: %v",
        DirNotExist:     "Directory does not exist: %s",
        FileNotFound:    "File not found: %s",
        InvalidPath:     "Invalid file path: %v",
        TranscribeFail:  "Transcription failed: %v",
        UnsupportedOS:   "Log viewing not supported on this platform",

        // Recording messages
        RecordingDevice: "Recording Device",
        Recording:       "Recording",
        RecordingStop:   "Recording stopped: %s",
        SelectDevice:    "Select recording device",
}

var messagesJA = Messages{
        // Main UI
        Active:     "稼働中",
        Processing: "処理中",
        Queue:      "待機",
        None:       "なし",
        Input:      "入力",
        Output:     "出力",
        Archive:    "アーカイブ",
        Last:       "最終",
        Next:       "次回",
        Never:      "未実行",
        Soon:       "まもなく",
        Uptime:     "稼働時間",

        // Commands
        ConfigCmd:    "設定",
        LogsCmd:      "ログ",
        ScanCmd:      "スキャン",
        QuitCmd:      "終了",
        InputDirCmd:  "入力",
        OutputDirCmd: "出力",
        RecordCmd:    "録音",

        // Log levels
        LogInfo:  "情報",
        LogProc:  "処理",
        LogDone:  "完了",
        LogError: "エラー",
        LogDebug: "デバッグ",

        // Processing messages
        AppStarted:      "KoeMoji-Go v%s を開始しました",
        AppRunning:      "KoeMoji-Goが実行中です。以下のコマンドを使用してください。",
        MonitoringDir:   "%sディレクトリを%d分ごとに監視しています",
        ShuttingDown:    "KoeMoji-Goを終了しています...",
        ScanningDir:     "音声ファイルをスキャンしています...",
        FoundFiles:      "%d個の音声ファイルを検出しました",
        ProcessingFile:  "%sを処理中",
        ProcessComplete: "%sの処理を完了 (処理時間: %s)",
        ProcessFailed:   "%sの処理に失敗: %v",
        MovingToArchive: "%sをアーカイブに移動",

        // Error messages
        LogFileError:    "ログファイルを開けません: %v",
        ConfigLoadError: "設定の読み込みに失敗: %v",
        ConfigSaveError: "設定の保存に失敗: %v",
        DirCreateError:  "ディレクトリ%sの作成に失敗: %v",
        DirNotExist:     "ディレクトリが存在しません: %s",
        FileNotFound:    "ファイルが見つかりません: %s",
        InvalidPath:     "無効なファイルパス: %v",
        TranscribeFail:  "文字起こしに失敗: %v",
        UnsupportedOS:   "このプラットフォームではログ表示はサポートされていません",

        // Recording messages
        RecordingDevice: "録音デバイス",
        Recording:       "録音中",
        RecordingStop:   "録音を停止しました: %s",
        SelectDevice:    "録音デバイスを選択",
}

// GetMessages returns the messages for the current UI language
func GetMessages(config *config.Config) *Messages <span class="cov0" title="0">{
        if config != nil &amp;&amp; config.UILanguage == "ja" </span><span class="cov0" title="0">{
                return &amp;messagesJA
        }</span>
        <span class="cov0" title="0">return &amp;messagesEN</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package ui

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/hirokitakamura/koemoji-go/internal/config"
        "github.com/hirokitakamura/koemoji-go/internal/logger"
)

// Color constants
const (
        ColorReset  = "\033[0m"
        ColorRed    = "\033[31m" // ERROR
        ColorGreen  = "\033[32m" // DONE
        ColorYellow = "\033[33m" // PROC
        ColorBlue   = "\033[34m" // INFO
        ColorGray   = "\033[37m" // DEBUG
)

// UI functions
func RefreshDisplay(config *config.Config, startTime, lastScanTime time.Time, logBuffer *[]logger.LogEntry,
        logMutex *sync.RWMutex, inputCount, outputCount, archiveCount int, queuedFiles *[]string,
        processingFile string, isProcessing bool, mu *sync.Mutex,
        isRecording bool, recordingStartTime time.Time) <span class="cov0" title="0">{

        if config == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Clear screen and move cursor to top
        <span class="cov0" title="0">fmt.Print("\033[2J\033[H")

        displayHeader(config, startTime, lastScanTime, inputCount, outputCount, archiveCount,
                queuedFiles, processingFile, isProcessing, mu, isRecording, recordingStartTime)
        displayRealtimeLogs(config, logBuffer, logMutex)
        displayCommands(config)</span>
}

func displayHeader(config *config.Config, startTime, lastScanTime time.Time, inputCount, outputCount, archiveCount int,
        queuedFiles *[]string, processingFile string, isProcessing bool, mu *sync.Mutex,
        isRecording bool, recordingStartTime time.Time) <span class="cov0" title="0">{

        updateFileCounts(config, &amp;inputCount, &amp;outputCount, &amp;archiveCount)
        msg := GetMessages(config)

        status := "🟢 " + msg.Active
        if isProcessing </span><span class="cov0" title="0">{
                status = "🟡 " + msg.Processing
        }</span>

        <span class="cov0" title="0">uptime := time.Since(startTime)

        fmt.Println("=== KoeMoji-Go v1.2.0 ===")

        mu.Lock()
        queueCount := len(*queuedFiles)
        processingDisplay := msg.None
        if processingFile != "" </span><span class="cov0" title="0">{
                processingDisplay = processingFile
        }</span>
        <span class="cov0" title="0">mu.Unlock()

        fmt.Printf("%s | %s: %d | %s: %s\n",
                status, msg.Queue, queueCount, msg.Processing, processingDisplay)
        fmt.Printf("📁 %s: %d → %s: %d → %s: %d\n",
                msg.Input, inputCount, msg.Output, outputCount, msg.Archive, archiveCount)

        // Recording status
        if isRecording </span><span class="cov0" title="0">{
                elapsed := time.Since(recordingStartTime)
                fmt.Printf("🔴 %s - %s\n", msg.Recording, formatDuration(elapsed))
        }</span>

        <span class="cov0" title="0">lastScanStr := msg.Never
        nextScanStr := msg.Soon
        if !lastScanTime.IsZero() </span><span class="cov0" title="0">{
                lastScanStr = lastScanTime.Format("15:04:05")
                nextScan := lastScanTime.Add(time.Duration(config.ScanIntervalMinutes) * time.Minute)
                nextScanStr = nextScan.Format("15:04:05")
        }</span>

        <span class="cov0" title="0">fmt.Printf("⏰ %s: %s | %s: %s | %s: %s\n",
                msg.Last, lastScanStr, msg.Next, nextScanStr, msg.Uptime, formatDuration(uptime))
        fmt.Println()</span>
}

func displayRealtimeLogs(config *config.Config, logBuffer *[]logger.LogEntry, logMutex *sync.RWMutex) <span class="cov0" title="0">{
        logMutex.RLock()
        defer logMutex.RUnlock()
        msg := GetMessages(config)

        for _, entry := range *logBuffer </span><span class="cov0" title="0">{
                color := getLogColor(config, entry.Level)
                timestamp := entry.Timestamp.Format("15:04:05")

                // Convert log level to localized version
                localizedLevel := entry.Level
                switch entry.Level </span>{
                case "INFO":<span class="cov0" title="0">
                        localizedLevel = msg.LogInfo</span>
                case "PROC":<span class="cov0" title="0">
                        localizedLevel = msg.LogProc</span>
                case "DONE":<span class="cov0" title="0">
                        localizedLevel = msg.LogDone</span>
                case "ERROR":<span class="cov0" title="0">
                        localizedLevel = msg.LogError</span>
                case "DEBUG":<span class="cov0" title="0">
                        localizedLevel = msg.LogDebug</span>
                }

                <span class="cov0" title="0">if color != "" </span><span class="cov0" title="0">{
                        fmt.Printf("%s%-5s%s %s %s\n", color, localizedLevel, ColorReset, timestamp, entry.Message)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("[%s] %s %s\n", localizedLevel, timestamp, entry.Message)
                }</span>
        }

        // Fill remaining lines to maintain 12-line display
        <span class="cov0" title="0">for i := len(*logBuffer); i &lt; 12; i++ </span><span class="cov0" title="0">{
                fmt.Println()
        }</span>
}

func displayCommands(config *config.Config) <span class="cov0" title="0">{
        msg := GetMessages(config)
        fmt.Printf("c=%s l=%s s=%s i=%s o=%s r=%s q=%s\n", msg.ConfigCmd, msg.LogsCmd, msg.ScanCmd, msg.InputDirCmd, msg.OutputDirCmd, msg.RecordCmd, msg.QuitCmd)
        fmt.Print("&gt; ")
}</span>

func DisplayLogs(config *config.Config) <span class="cov0" title="0">{
        msg := GetMessages(config)

        if _, err := os.Stat("koemoji.log"); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println(msg.FileNotFound)
                return
        }</span>

        <span class="cov0" title="0">var cmd *exec.Cmd
        switch runtime.GOOS </span>{
        case "windows":<span class="cov0" title="0">
                cmd = exec.Command("notepad", "koemoji.log")</span>
        case "darwin":<span class="cov0" title="0">
                cmd = exec.Command("open", "koemoji.log")</span>
        default:<span class="cov0" title="0">
                fmt.Println(msg.UnsupportedOS)
                return</span>
        }

        <span class="cov0" title="0">if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf(msg.LogFileError, err)
        }</span>
}

func OpenDirectory(dirPath string) error <span class="cov0" title="0">{
        var cmd *exec.Cmd
        switch runtime.GOOS </span>{
        case "windows":<span class="cov0" title="0">
                cmd = exec.Command("explorer", dirPath)</span>
        case "darwin":<span class="cov0" title="0">
                cmd = exec.Command("open", dirPath)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("opening directories not supported on this platform")</span>
        }

        <span class="cov0" title="0">return cmd.Start()</span>
}

// Utility functions
func supportsColor(config *config.Config) bool <span class="cov0" title="0">{
        if config == nil || !config.UseColors </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                return true // Windows 10以降は強制有効
        }</span>

        <span class="cov0" title="0">term := os.Getenv("TERM")
        return term != "" &amp;&amp; term != "dumb"</span>
}

func getLogColor(config *config.Config, level string) string <span class="cov0" title="0">{
        if !supportsColor(config) </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">switch level </span>{
        case "INFO":<span class="cov0" title="0">
                return ColorBlue</span>
        case "PROC":<span class="cov0" title="0">
                return ColorYellow</span>
        case "DONE":<span class="cov0" title="0">
                return ColorGreen</span>
        case "ERROR":<span class="cov0" title="0">
                return ColorRed</span>
        case "DEBUG":<span class="cov0" title="0">
                return ColorGray</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        hours := int(d.Hours())
        minutes := int(d.Minutes()) % 60
        seconds := int(d.Seconds()) % 60

        if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh%dm%ds", hours, minutes, seconds)
        }</span> else<span class="cov0" title="0"> if minutes &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm%ds", minutes, seconds)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%ds", seconds)
        }</span>
}

func updateFileCounts(config *config.Config, inputCount, outputCount, archiveCount *int) <span class="cov0" title="0">{
        // Count files in each directory
        if entries, err := os.ReadDir(config.InputDir); err == nil </span><span class="cov0" title="0">{
                *inputCount = 0
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if !entry.IsDir() &amp;&amp; IsAudioFile(entry.Name()) </span><span class="cov0" title="0">{
                                (*inputCount)++
                        }</span>
                }
        }

        <span class="cov0" title="0">if entries, err := os.ReadDir(config.OutputDir); err == nil </span><span class="cov0" title="0">{
                *outputCount = len(entries)
        }</span>

        <span class="cov0" title="0">if entries, err := os.ReadDir(config.ArchiveDir); err == nil </span><span class="cov0" title="0">{
                *archiveCount = len(entries)
        }</span>
}

func IsAudioFile(filename string) bool <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(filename))
        audioExts := []string{".mp3", ".wav", ".m4a", ".flac", ".ogg", ".aac", ".mp4", ".mov", ".avi"}
        for _, audioExt := range audioExts </span><span class="cov0" title="0">{
                if ext == audioExt </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package whisper

import (
        "bufio"
        "fmt"
        "io"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/hirokitakamura/koemoji-go/internal/config"
        "github.com/hirokitakamura/koemoji-go/internal/logger"
        "github.com/hirokitakamura/koemoji-go/internal/ui"
)

func getWhisperCommand() string <span class="cov8" title="1">{
        // 1. 通常のPATHで試す
        if _, err := exec.LookPath("whisper-ctranslate2"); err == nil </span><span class="cov0" title="0">{
                return "whisper-ctranslate2"
        }</span>

        // 2. 標準的なインストール場所を検索
        <span class="cov8" title="1">standardPaths := []string{
                filepath.Join(os.Getenv("HOME"), ".local", "bin", "whisper-ctranslate2"),                    // macOS user install
                "/usr/local/bin/whisper-ctranslate2",                                                        // macOS system
                filepath.Join(os.Getenv("HOME"), "Library", "Python", "3.12", "bin", "whisper-ctranslate2"), // macOS Python 3.12
                filepath.Join(os.Getenv("HOME"), "Library", "Python", "3.11", "bin", "whisper-ctranslate2"), // macOS Python 3.11
                filepath.Join(os.Getenv("HOME"), "Library", "Python", "3.10", "bin", "whisper-ctranslate2"), // macOS Python 3.10
                filepath.Join(os.Getenv("HOME"), "Library", "Python", "3.9", "bin", "whisper-ctranslate2"),  // macOS Python 3.9
        }

        for _, path := range standardPaths </span><span class="cov8" title="1">{
                if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                        return path
                }</span>
        }

        <span class="cov8" title="1">return "whisper-ctranslate2"</span> // フォールバック
}

func isFasterWhisperAvailable() bool <span class="cov0" title="0">{
        cmd := exec.Command(getWhisperCommand(), "--help")
        cmd.Stdout = nil
        cmd.Stderr = nil
        return cmd.Run() == nil
}</span>

func installFasterWhisper(log *log.Logger, logBuffer *[]logger.LogEntry, logMutex *sync.RWMutex) error <span class="cov0" title="0">{
        logger.LogInfo(log, logBuffer, logMutex, "Installing faster-whisper and whisper-ctranslate2...")
        cmd := exec.Command("pip", "install", "faster-whisper", "whisper-ctranslate2")
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pip install failed: %w", err)
        }</span>
        <span class="cov0" title="0">logger.LogInfo(log, logBuffer, logMutex, "FasterWhisper installed successfully")
        return nil</span>
}

func TranscribeAudio(config *config.Config, log *log.Logger, logBuffer *[]logger.LogEntry,
        logMutex *sync.RWMutex, debugMode bool, inputFile string) error <span class="cov0" title="0">{

        // セキュリティチェック: inputディレクトリ内のファイルのみ許可
        absPath, err := filepath.Abs(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                msg := ui.GetMessages(config)
                return fmt.Errorf(msg.InvalidPath, err)
        }</span>
        <span class="cov0" title="0">inputDir, _ := filepath.Abs(config.InputDir)
        if !strings.HasPrefix(absPath, inputDir+string(os.PathSeparator)) </span><span class="cov0" title="0">{
                msg := ui.GetMessages(config)
                return fmt.Errorf(msg.InvalidPath, inputFile)
        }</span>

        <span class="cov0" title="0">whisperCmd := getWhisperCommand()

        cmd := exec.Command(whisperCmd,
                "--model", config.WhisperModel,
                "--language", config.Language,
                "--output_dir", config.OutputDir,
                "--output_format", config.OutputFormat,
                "--compute_type", config.ComputeType,
                "--verbose", "True", // Enable verbose for progress
                inputFile,
        )

        logger.LogDebug(log, logBuffer, logMutex, debugMode, "Whisper command: %s", strings.Join(cmd.Args, " "))

        // Start progress monitoring
        startTime := time.Now()
        done := make(chan bool)

        // Monitor progress in background
        go monitorProgress(log, logBuffer, logMutex, filepath.Base(inputFile), startTime, done)

        // Capture and display output
        stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                done &lt;- true
                return fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov0" title="0">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                done &lt;- true
                return fmt.Errorf("failed to create stderr pipe: %w", err)
        }</span>

        // Start command
        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                done &lt;- true
                return fmt.Errorf("failed to start command: %w", err)
        }</span>

        // Read output in background
        <span class="cov0" title="0">go readCommandOutput(log, logBuffer, logMutex, debugMode, stdout, "STDOUT")
        go readCommandOutput(log, logBuffer, logMutex, debugMode, stderr, "STDERR")

        // Wait for completion
        err = cmd.Wait()

        // Stop progress monitoring
        done &lt;- true

        if err != nil </span><span class="cov0" title="0">{
                msg := ui.GetMessages(config)
                return fmt.Errorf(msg.TranscribeFail, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func readCommandOutput(log *log.Logger, logBuffer *[]logger.LogEntry, logMutex *sync.RWMutex,
        debugMode bool, pipe io.ReadCloser, source string) <span class="cov0" title="0">{

        defer pipe.Close()
        scanner := bufio.NewScanner(pipe)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line != "" </span><span class="cov0" title="0">{
                        // Log other output for debugging
                        logger.LogDebug(log, logBuffer, logMutex, debugMode, "[%s] %s", source, line)
                }</span>
        }
}

func monitorProgress(log *log.Logger, logBuffer *[]logger.LogEntry, logMutex *sync.RWMutex,
        filename string, startTime time.Time, done chan bool) <span class="cov0" title="0">{

        ticker := time.NewTicker(30 * time.Second) // 30秒ごとに進行状況を報告
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        elapsed := time.Since(startTime)
                        logger.LogInfo(log, logBuffer, logMutex, "Still processing %s (elapsed: %s)", filename, formatDuration(elapsed))</span>
                }
        }
}

func EnsureDependencies(config *config.Config, log *log.Logger, logBuffer *[]logger.LogEntry,
        logMutex *sync.RWMutex, debugMode bool) <span class="cov0" title="0">{

        if !isFasterWhisperAvailable() </span><span class="cov0" title="0">{
                logger.LogInfo(log, logBuffer, logMutex, "FasterWhisper not found. Attempting to install...")
                if err := installFasterWhisper(log, logBuffer, logMutex); err != nil </span><span class="cov0" title="0">{
                        logger.LogError(log, logBuffer, logMutex, "FasterWhisper installation failed: %v", err)
                        logger.LogError(log, logBuffer, logMutex, "Please install manually: pip install faster-whisper whisper-ctranslate2")
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.LogDebug(log, logBuffer, logMutex, debugMode, "FasterWhisper is available")
        }</span>
}

func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        hours := int(d.Hours())
        minutes := int(d.Minutes()) % 60
        seconds := int(d.Seconds()) % 60

        if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh%dm%ds", hours, minutes, seconds)
        }</span> else<span class="cov0" title="0"> if minutes &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm%ds", minutes, seconds)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%ds", seconds)
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "bufio"
        "fmt"
        "log"
        "os"
        "strconv"
        "strings"

        "github.com/hirokitakamura/koemoji-go/internal/recorder"
)

func main() <span class="cov0" title="0">{
        fmt.Println("KoeMoji-Go Recorder Test v1.0")
        fmt.Println("==============================")

        // Test 1: List available devices
        fmt.Println("\n1. Testing device listing...")
        devices, err := recorder.ListDevices()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to list devices: %v", err)
        }</span>

        <span class="cov0" title="0">if len(devices) == 0 </span><span class="cov0" title="0">{
                log.Fatal("No input devices found")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d input devices:\n", len(devices))
        for i, device := range devices </span><span class="cov0" title="0">{
                prefix := fmt.Sprintf("  %d: %s", i, device.Name)
                if device.IsDefault </span><span class="cov0" title="0">{
                        prefix += " (default)"
                }</span>
                <span class="cov0" title="0">if device.IsVirtual </span><span class="cov0" title="0">{
                        prefix += fmt.Sprintf(" [%s]", device.VirtualType)
                }</span>
                <span class="cov0" title="0">fmt.Printf("%s (%d channels, %s)\n", prefix, device.MaxChannels, device.HostAPI)</span>
        }

        // Test 2: Select device
        <span class="cov0" title="0">fmt.Println("\n2. Device selection...")
        scanner := bufio.NewScanner(os.Stdin)

        fmt.Print("Select device (number) or press Enter for default: ")
        scanner.Scan()
        input := strings.TrimSpace(scanner.Text())

        var rec *recorder.Recorder
        if input == "" </span><span class="cov0" title="0">{
                fmt.Println("Using default device...")
                rec, err = recorder.NewRecorder()
        }</span> else<span class="cov0" title="0"> {
                deviceIndex, err2 := strconv.Atoi(input)
                if err2 != nil || deviceIndex &lt; 0 || deviceIndex &gt;= len(devices) </span><span class="cov0" title="0">{
                        log.Fatalf("Invalid device selection: %s", input)
                }</span>
                <span class="cov0" title="0">selectedDevice := devices[deviceIndex]
                fmt.Printf("Using device: %s\n", selectedDevice.Name)
                rec, err = recorder.NewRecorderWithDevice(selectedDevice.ID)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create recorder: %v", err)
        }</span>
        <span class="cov0" title="0">defer rec.Close()

        // Test 3: Interactive recording
        fmt.Println("\n3. Interactive recording test...")
        fmt.Println("Controls:")
        fmt.Println("  Enter - Start/Stop recording")
        fmt.Println("  q     - Quit")
        fmt.Println()

        recording := false
        recordingCount := 0

        for </span><span class="cov0" title="0">{
                if recording </span><span class="cov0" title="0">{
                        duration := rec.GetElapsedTime()
                        fmt.Printf("Recording... %.1fs (Enter to stop, q to quit): ", duration.Seconds())
                }</span> else<span class="cov0" title="0"> {
                        fmt.Print("Ready (Enter to start, q to quit): ")
                }</span>

                <span class="cov0" title="0">if !scanner.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">input := strings.TrimSpace(scanner.Text())

                if input == "q" </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if input == "" </span><span class="cov0" title="0">{
                        if recording </span><span class="cov0" title="0">{
                                // Stop recording
                                fmt.Println("Stopping recording...")
                                err = rec.Stop()
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Stop failed: %v", err)
                                        continue</span>
                                }

                                // Save file
                                <span class="cov0" title="0">recordingCount++
                                filename := fmt.Sprintf("test_recording_%d.wav", recordingCount)
                                fmt.Printf("Saving to %s...", filename)
                                err = rec.SaveToFile(filename)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Save failed: %v", err)
                                        continue</span>
                                }

                                <span class="cov0" title="0">duration := rec.GetDuration()
                                fmt.Printf(" Done! (%.1fs)\n", duration)
                                recording = false</span>
                        } else<span class="cov0" title="0"> {
                                // Start recording
                                fmt.Println("Starting recording...")
                                err = rec.Start()
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Start failed: %v", err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">recording = true</span>
                        }
                }
        }

        // Cleanup
        <span class="cov0" title="0">if recording </span><span class="cov0" title="0">{
                fmt.Println("Stopping recording...")
                rec.Stop()
                recordingCount++
                filename := fmt.Sprintf("test_recording_%d.wav", recordingCount)
                rec.SaveToFile(filename)
                fmt.Printf("Final recording saved: %s\n", filename)
        }</span>

        <span class="cov0" title="0">fmt.Println("Test completed!")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
